<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>소환수 배치 시뮬레이션</title>
    <style>
        /*
         * 전역 스타일 및 레이아웃 설정
         * 전체 페이지 콘텐츠를 세로로 중앙 정렬합니다.
         */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        /*
         * 전장 그리드 컨테이너 스타일
         * 17x9 크기의 전장 그리드를 정의하며, 셀 간격과 테두리를 설정합니다.
         */
        .battlefield-container {
            display: grid;
            grid-template-columns: repeat(17, 60px); /* 17개 열, 각 열 60px */
            grid-template-rows: repeat(9, 60px);   /* 9개 행, 각 행 60px */
            gap: 2px; /* 그리드 셀 사이 간격 */
            border: 2px solid #666; /* 테두리 */
            width: fit-content; /* 내용물에 맞춰 너비 자동 조절 */
            margin-bottom: 30px; /* 하단 여백 */
            background-color: #e0ffe0; /* 연한 초록색 배경 */
        }

        /*
         * 전장 그리드의 개별 셀 스타일
         * 셀의 기본 크기와 테두리, 그리고 소환수 개수에 따른 내부 그리드 레이아웃을 정의합니다.
         */
        .battlefield-cell {
            width: 60px;
            height: 60px;
            border: 1px dotted #aaa; /* 점선 테두리 */
            display: grid; 
            grid-template-columns: 1fr; /* 기본적으로 1x1 그리드 (소환수 1마리일 때) */
            grid-template-rows: 1fr;    /* 기본적으로 1x1 그리드 (소환수 1마리일 때) */
            gap: 0; /* 내부 그리드 셀 간격 없음 */
            font-size: 8px; /* 전장 소환수 내 텍스트 크기 (주로 사용되지 않음) */
            position: relative; /* 리더 마커 위치 지정을 위한 기준 */
            box-sizing: border-box; /* 패딩과 보더가 너비에 포함되도록 계산 */
            overflow: hidden; /* 내용이 넘치면 숨김 (소환수 크기가 셀에 맞춰지므로 주로 발생 안함) */
        }

        /* 소환수가 2마리일 때 전장 셀 내부 스타일 (가로 2분할, 세로 100%) */
        .battlefield-cell.multi-summoners {
            grid-template-columns: repeat(2, 1fr); /* 2개 열 (각 50% 너비) */
            grid-template-rows: 1fr; /* 1개 행 (세로 100% 사용) */
        }
        /* 소환수가 3마리 이상일 때 전장 셀 내부 스타일 (2x2 분할) */
        .battlefield-cell.multi-summoners.three-plus {
            grid-template-rows: repeat(2, 1fr); /* 2개 행 (각 50% 높이) */
        }
        /* 전장의 공유 영역 셀 배경색 */
        .battlefield-cell.shared-column {
            background-color: #d0d0ff; /* 연한 보라색 배경 */
        }
        
        /*
         * 전장에 배치되는 소환수 이미지 컨테이너 스타일
         * 이 요소는 전장 셀 내의 하위 그리드 아이템으로 동작합니다.
         */
        .battlefield-summoner {
            border-radius: 3px; /* 모서리를 둥글게 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white; /* 텍스트 색상 (이름 대신 이미지를 사용하므로 잘 보이지 않음) */
            font-weight: bold;
            font-size: 8px; 
            text-align: center;
            line-height: 1;
            padding: 1px; /* 내부 여백 */
            box-sizing: border-box;
            margin: 0; /* 내부 그리드 아이템이므로 기본 마진 없음 */
            overflow: hidden; /* 이미지가 넘치면 숨김 */
        }
        /* 전장 소환수 내부 이미지 스타일 */
        .battlefield-summoner img {
            width: 100%; /* 부모 요소(battlefield-summoner) 크기에 꽉 채움 */
            height: 100%;
            object-fit: cover; /* 이미지가 잘리지 않고 영역을 채우도록 */
            border-radius: 3px; /* 부모 요소와 동일하게 둥글게 */
        }

        /* 전장 소환수: 1마리일 때 크기 (셀 전체 사용) */
        .battlefield-summoner.single-summoner {
            width: calc(100% - 2px); /* 셀 가로 너비에서 좌우 1px 마진 제외 */
            height: calc(100% - 2px); /* 셀 세로 높이에서 상하 1px 마진 제외 */
            margin: 1px; /* 셀 테두리 및 소환수 간 여백 */
        }
        /* 전장 소환수: 2마리 이상일 때 크기 (하위 그리드 셀에 맞춰 조정) */
        .battlefield-summoner.multi-summoner {
            width: calc(100% - 2px); /* 하위 그리드 열의 100%에서 좌우 1px 마진 제외 */
            height: calc(100% - 2px); /* 하위 그리드 행의 100%에서 상하 1px 마진 제외 */
            margin: 1px; /* 하위 셀 내에서 마진 */
        }

        /* 나의 소환수 배경색 */
        .battlefield-summoner.my-summoner {
            background-color: #2196F3; /* 파란색 */
        }
        /* 상대편 소환수 배경색 */
        .battlefield-summoner.opponent-summoner {
            background-color: #f44336; /* 빨간색 */
        }
        /* 전장 리더 마커 (작은 왕관 이모지) */
        .battlefield-leader-marker {
            position: absolute;
            top: 1px;
            right: 1px;
            font-size: 7px;
            color: gold;
            text-shadow: 0.5px 0.5px 1px rgba(0,0,0,0.7);
        }

        /*
         * 배치 그리드 섹션 스타일 (나의 배치 그리드와 상대편 배치 그리드를 포함)
         * 두 그리드를 가로로 나란히 배치하고 중앙 정렬합니다.
         */
        .placement-section {
            display: flex;
            width: 100%;
            justify-content: center; /* 중앙 정렬 */
            gap: 50px; /* 그리드 컨테이너 사이 간격 */
            margin-bottom: 30px; /* 하단 여백 */
        }

        /* 개별 배치 그리드 래퍼 (제목, 카운트 UI, 실제 그리드를 포함) */
        .grid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* 배치 수 UI를 위한 위치 기준 */
        }

        /* 배치된 소환수 수를 표시하는 UI (예: "N/15") */
        .grid-count-display {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: rgba(0, 0, 0, 0.7); /* 반투명 검정 배경 */
            color: white; /* 흰색 텍스트 */
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            z-index: 20; /* 다른 요소 위에 표시되도록 */
        }

        /* 5x5 배치 그리드 컨테이너 */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(5, 60px); /* 5개 열, 각 60px */
            grid-template-rows: repeat(5, 60px);   /* 5개 행, 각 60px */
            gap: 5px; /* 셀 사이 간격 */
            border: 2px solid #333; /* 테두리 */
            width: fit-content; /* 내용물에 맞춰 너비 자동 조절 */
        }
        /* 배치 그리드의 개별 셀 */
        .grid-cell {
            width: 60px;
            height: 60px;
            border: 1px solid #ccc; /* 옅은 회색 테두리 */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: default; /* 셀 자체는 클릭 가능하지 않음 (버튼 사용) */
            background-color: #f0f0f0; /* 연한 회색 배경 */
            position: relative; /* 소환수 버튼 위치 지정을 위한 기준 */
        }

        /*
         * 소환수 기본 스타일 (풀의 소환수, 배치 그리드의 소환수에 모두 적용)
         * 이 스타일은 .battlefield-summoner 스타일에 의해 일부 오버라이드될 수 있습니다.
         */
        .summoner { 
            width: 50px; /* 기본 소환수 크기 */
            height: 50px; 
            background-color: #4CAF50; /* 풀에 있을 때의 기본색 (초록색) */
            border-radius: 5px; /* 모서리 둥글게 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white; /* 텍스트 색상 (이름 대신 이미지) */
            font-weight: bold;
            font-size: 10px;
            text-align: center;
            line-height: 1.2;
            padding: 2px; /* 내부 여백 */
            box-sizing: border-box;
            position: relative; /* 소환수 버튼 위치 지정을 위한 기준 */
            overflow: hidden; /* 내부 이미지가 넘치면 숨김 */
        }
        /* 소환수 내부 이미지 스타일 (풀 및 배치 그리드) */
        .summoner img {
            width: 100%; /* 부모 소환수 크기에 꽉 채움 */
            height: 100%;
            object-fit: cover; /* 이미지가 잘리지 않고 영역을 채우도록 */
            border-radius: 5px; /* 부모와 동일하게 둥글게 */
        }

        /* 드래그 가능한 풀 소환수 (풀에 있을 때만 적용되는 추가 스타일) */
        .summoner-draggable {
            cursor: grab; /* 드래그 가능한 커서 모양 */
            margin: 5px; /* 풀 내 소환수 사이 간격 */
            background-color: #4CAF50; /* 풀의 소환수는 기본 초록색으로 통일 */
        }
        /* 배치된 나의 소환수 색상 (is-placed 데이터 속성 확인) */
        .summoner[data-is-opponent="false"].is-placed {
            background-color: #2196F3; /* 파란색 */
        }
        /* 배치된 상대편 소환수 색상 (is-placed 데이터 속성 확인) */
        .summoner[data-is-opponent="true"].is-placed {
            background-color: #f44336; /* 빨간색 */
        }

        /* 리더 소환수 테두리 효과 */
        .is-leader {
            border: 3px solid gold; /* 금색 테두리 */
            box-shadow: 0 0 10px gold; /* 금색 그림자 효과 */
        }
        /* 소환수 위에 표시되는 버튼 공통 스타일 (리더 버튼, 제거 버튼) */
        .summoner-button {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%; /* 원형 버튼 */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10; /* 소환수 위에 표시되도록 */
        }
        /* 리더 지정 버튼 스타일 */
        .leader-button {
            top: -5px; /* 소환수 좌측 상단으로 이동 */
            left: -5px;
            background-color: #ffd700; /* 금색 배경 */
            color: #333; /* 어두운 글자색 */
            border: 1px solid #ccaa00;
        }
        .leader-button:hover {
            background-color: #ffeb3b; /* 호버 시 밝게 */
        }
        /* 제거 버튼 스타일 */
        .remove-button {
            top: -5px; /* 소환수 우측 상단으로 이동 */
            right: -5px;
            background-color: #f44336; /* 빨간색 배경 */
            color: white; /* 흰색 글자 */
            border: 1px solid #d32f2f;
        }
        .remove-button:hover {
            background-color: #ef5350; /* 호버 시 밝게 */
        }

        /*
         * 공용 소환수 풀 컨테이너 스타일
         * 모든 소환수 이미지 요소들을 담고 줄바꿈하여 표시합니다.
         */
        .summoners-pool {
            display: flex;
            flex-wrap: wrap; /* 소환수들이 많으면 다음 줄로 줄바꿈 */
            gap: 10px; /* 소환수 요소들 사이 간격 */
            margin-top: 20px;
            border: 1px solid #eee; /* 옅은 회색 테두리 */
            padding: 10px; /* 내부 여백 */
            width: 1000px; /* 전장 그리드 너비에 맞춰 설정 */
            justify-content: center; /* 중앙 정렬 */
            margin-bottom: 20px;
        }

        /* 제어 버튼 그룹 스타일 */
        .control-buttons {
            margin-top: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap; /* 버튼이 많아지면 줄바꿈 */
            gap: 15px;
            align-items: center; /* 수직 정렬 */
            justify-content: center; /* 중앙 정렬 */
            width: 1000px; /* 전체 너비 */
            max-width: 100%;
        }
        .control-buttons button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s;
            flex-shrink: 0; /* 버튼이 줄어들지 않도록 */
        }
        .control-buttons button:hover {
            background-color: #0056b3;
        }
        .control-buttons button.clear-button {
            background-color: #dc3545;
        }
        .control-buttons button.clear-button:hover {
            background-color: #c82333;
        }

        /* 편성 선택 버튼 컨테이너 스타일 */
        .arrangement-selection {
            display: flex;
            flex-wrap: nowrap; /* 변경: 줄바꿈 대신 스크롤 */
            overflow-x: auto;  /* 내용이 넘치면 가로 스크롤바 표시 */
            gap: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 5px;
            flex-grow: 1; /* 남은 공간을 채우도록 성장 */
            justify-content: flex-start; /* 좌측 정렬 */
            align-items: center;
            min-width: 200px; /* 최소 너비 설정 */
        }
        /* 편성 선택 버튼 개별 스타일 */
        .arrangement-selection button {
            padding: 8px 12px;
            font-size: 14px;
            background-color: #e9ecef;
            color: #495057;
            border: 1px solid #adb5bd;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            flex-shrink: 0; /* 버튼이 줄어들지 않도록 */
        }
        .arrangement-selection button:hover {
            background-color: #dee2e6;
        }
        .arrangement-selection button.active-arrangement {
            background-color: #28a745; /* 활성화된 편성 색상 (초록색) */
            color: white;
            border-color: #218838;
            font-weight: bold;
        }

        /* 편성 추가 버튼 (플러스 버튼) 스타일 */
        .arrangement-selection button.add-arrangement-button {
            background-color: #6c757d; /* 회색 배경 */
            color: white;
            font-weight: bold;
            font-size: 18px; /* 크게 */
            padding: 5px 10px; /* 패딩 조정 */
        }
        .arrangement-selection button.add-arrangement-button:hover {
            background-color: #5a6268;
        }
        /* 편성 이름 변경 버튼 */
        .arrangement-selection .rename-arrangement-button {
            background-color: #17a2b8; /* 청록색 */
            color: white;
            font-weight: bold;
            font-size: 10px;
            width: 18px;
            height: 18px;
            line-height: 1;
            border-radius: 50%;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 4px; /* 왼쪽 버튼과의 간격 */
            border: none;
        }
        .arrangement-selection .rename-arrangement-button:hover {
            background-color: #138496;
        }
        /* 편성 삭제 버튼 (편성 버튼 옆에 작은 X 버튼) */
        .arrangement-selection .delete-arrangement-button {
            background-color: #dc3545; /* 빨간색 */
            color: white;
            font-weight: bold;
            font-size: 10px;
            width: 18px; /* 작게 */
            height: 18px;
            line-height: 1;
            border-radius: 50%; /* 원형 */
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 4px; /* 왼쪽 버튼과의 간격 */
            border: none;
            z-index: 5; 
            position: relative;
        }
        .arrangement-selection .delete-arrangement-button:hover {
            background-color: #c82333;
        }
        /* 편성 버튼과 삭제 버튼을 묶는 컨테이너 */
        .arrangement-item {
            display: flex;
            align-items: center;
            flex-shrink: 0; /* 아이템이 줄어들지 않도록 */
        }

        /* 토스트 메시지 스타일 */
        #toast-message {
            visibility: hidden; /* 기본적으로 숨김 */
            min-width: 250px;
            background-color: rgba(51, 51, 51, 0.9); /* 반투명 검정 배경 */
            color: #fff;
            text-align: center;
            border-radius: 5px;
            padding: 16px;
            position: fixed; /* 고정 위치 */
            z-index: 9999; /* 다른 요소 위에 표시 */
            left: 50%; /* 가로 중앙 */
            top: 50%; /* 세로 중앙 (translate로 정확한 중앙 조정) */
            transform: translate(-50%, -50%); /* 정확한 중앙 정렬 */
            opacity: 0; /* 초기 투명도 */
            transition: opacity 0.5s, visibility 0.5s; /* 부드러운 나타남/사라짐 효과 */
        }
        #toast-message.show {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <h1>소환수 배치 시뮬레이션</h1>

    <h2>전장</h2>
    <div id="battlefield-grid" class="battlefield-container">
        </div>

    <div class="placement-section">
        <div class="grid-wrapper">
            <h2>나의 배치</h2>
            <div id="my-grid-count" class="grid-count-display">0/15</div> 
            <div id="my-grid" class="grid-container">
                </div>
        </div>

        <div class="grid-wrapper">
            <h2>상대편 배치</h2>
            <div id="opponent-grid-count" class="grid-count-display">0/15</div> 
            <div id="opponent-grid" class="grid-container">
                </div>
        </div>
    </div>

    <div class="control-buttons">
        <div class="arrangement-selection" id="arrangement-buttons-container">
            <!-- 편성 버튼들이 여기에 동적으로 생성될 것입니다 -->
            <button class="add-arrangement-button" id="add-arrangement-button-id">+</button>
        </div>
        <button id="save-arrangement-button">현재 편성 저장</button>
        <button id="clear-current-arrangement-button">현재 편성 비우기</button>
        <button id="clear-all-arrangements-button" class="clear-button">모든 편성 초기화</button>
    </div>

    <hr>

    <h3>소환수 목록 (풀에서 드래그하여 배치)</h3>
    <div id="common-summoners-pool" class="summoners-pool">
        </div>

    <!-- 토스트 메시지 영역 -->
    <div id="toast-message"></div>

    <script>
        // DOM 요소에 대한 참조를 미리 가져와서 사용합니다.
        const opponentGrid = document.getElementById('opponent-grid');
        const myGrid = document.getElementById('my-grid');
        const commonSummonersPool = document.getElementById('common-summoners-pool');
        const battlefieldGrid = document.getElementById('battlefield-grid');
        const myGridCountDisplay = document.getElementById('my-grid-count');
        const opponentGridCountDisplay = document.getElementById('opponent-grid-count');
        const arrangementButtonsContainer = document.getElementById('arrangement-buttons-container');
        const addArrangementButton = document.getElementById('add-arrangement-button-id'); // + 버튼 참조 추가
        const toastMessage = document.getElementById('toast-message'); // 토스트 메시지 DOM 추가

        // 게임의 전반적인 설정을 위한 상수들
        const grid5x5Size = 5; // 배치 그리드의 크기 (5x5 셀)
        const maxSummoners = 15; // 각 진영이 배치할 수 있는 최대 소환수 수
        const maxArrangements = 10; // 최대 편성 슬롯 개수

        // 전장 그리드의 크기 설정
        const battlefieldCols = 17; // 전장 그리드의 열 개수
        const battlefieldRows = 9;   // 전장 그리드의 행 개수
        
        // 전장 그리드의 세로 중앙 행을 계산합니다 (9행의 경우 인덱스 4).
        const battlefieldVerticalCenterRow = Math.floor(battlefieldRows / 2); 

        // 나의 리더가 전장에서 배치될 열의 인덱스 (5번째 열, 즉 인덱스 4)
        const myLeaderBattlefieldCol = 6; 
        // 상대편 리더가 전장에서 배치될 열의 인덱스 (13번째 열, 즉 인덱스 12)
        const opponentLeaderBattlefieldCol = 10;

        // 게임에 사용될 소환수들의 이름 목록을 가나다순으로 정렬합니다.
        const summonerNames = [
            '사브리나', '테사리온', '아르타미엘', '투전승불', '라이마', '멜리사', '카산드라', 
            '샬롯', '애너벨', '잔느', '시화', '그로겐', '리나', '델포이', '오필리아', 
            '바네사', '풍연', '베르데하일', '루쉔', '셀레스티아', '아이리엘', '라피스', 
            '알리시아', '테트라', '채선', '갤리온', '미후왕'
        ].sort();

        // 현재 나의 진영과 상대편 진영에 배치된 소환수 수를 추적하는 변수
        let myPlacedSummoners = 0;
        let opponentPlacedSummoners = 0;

        // 현재 각 진영의 리더 소환수 엘리먼트 (DOM 참조)를 저장하는 변수
        let myLeaderSummoner = null;
        let opponentLeaderSummoner = null;

        // 현재 활성화된 편성 번호
        let currentArrangementId = 1; 
        // 편성 목록 (예: [1, 2, 3])
        let availableArrangementIds = [];
        // 편성 이름 목록 (예: { "1": "공격덱" })
        let arrangementNames = {};

        // 배치 변경 여부 플래그
        let isDirty = false;

        // 소환수 이미지 파일의 기본 경로와 확장자를 정의합니다.
        const imagePath = 'summoner_images/'; // 예: 'summoner_images/' 폴더에 이미지가 있다고 가정
        const imageExtension = '.png'; // 모든 이미지가 PNG 형식이라고 가정

        // 토스트 메시지 타임아웃을 관리하기 위한 변수
        let toastTimeout;

        /**
         * 5x5 크기의 배치 그리드 셀들을 동적으로 생성하고 초기화합니다.
         * 각 셀에는 드래그 오버 및 드롭 이벤트를 처리할 리스너가 추가됩니다.
         * @param {HTMLElement} gridElement - 셀들이 추가될 그리드 컨테이너 DOM 요소 (예: myGrid, opponentGrid)
         * @param {string} gridType - 이 그리드가 'my' (나의 진영) 또는 'opponent' (상대편 진영) 중 무엇인지 구분합니다.
         */
        function createGrid(gridElement, gridType) {
            gridElement.innerHTML = ''; // 기존 셀들을 초기화
            for (let i = 0; i < grid5x5Size * grid5x5Size; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.index = i; // 셀의 순서 인덱스를 데이터 속성으로 저장
                gridElement.appendChild(cell);

                cell.addEventListener('dragover', dragOver); // 드래그 오버 시 허용 처리
                cell.addEventListener('drop', (e) => drop(e, gridType)); // 드롭 시 처리
            }
        }

        /**
         * 17x9 크기의 전장 그리드 셀들을 동적으로 생성하고 초기화합니다.
         * 전장 셀의 중앙 공유 영역에 특별한 배경 스타일을 적용합니다.
         */
        function createBattlefieldGrid() {
            battlefieldGrid.innerHTML = ''; // 기존 셀들을 초기화
            for (let i = 0; i < battlefieldCols * battlefieldRows; i++) {
                const cell = document.createElement('div');
                cell.classList.add('battlefield-cell');
                const colIndex = i % battlefieldCols; // 현재 셀의 열 인덱스
                // 나의 리더 열과 상대 리더 열 사이를 공유 영역으로 표시
                if (colIndex > myLeaderBattlefieldCol && colIndex < opponentLeaderBattlefieldCol) { 
                     cell.classList.add('shared-column'); // 공유 영역 스타일 클래스 추가
                }
                battlefieldGrid.appendChild(cell);
            }
        }

        /**
         * 공용 소환수 풀에 모든 소환수 이미지 요소들을 동적으로 생성합니다.
         * 각 소환수는 드래그 가능하며, 풀의 소환수에게는 리더/제거 버튼이 없습니다.
         */
        function createCommonSummonerPool() {
            commonSummonersPool.innerHTML = ''; // 기존 풀 내용을 초기화
            for (let i = 0; i < summonerNames.length; i++) { 
                const summoner = document.createElement('div');
                summoner.classList.add('summoner', 'summoner-draggable'); // 기본 스타일 및 드래그 가능 스타일
                
                const img = document.createElement('img');
                img.src = `${imagePath}${summonerNames[i]}${imageExtension}`; // 이미지 파일 경로 설정
                img.alt = summonerNames[i]; // 이미지 대체 텍스트 (접근성)
                summoner.appendChild(img);

                summoner.setAttribute('draggable', true); // HTML draggable 속성 활성화
                summoner.id = `summoner-pool-${summonerNames[i]}`; // 풀 내에서 고유한 ID 부여
                summoner.dataset.summonerName = summonerNames[i]; // 소환수 이름 데이터 속성 저장
                summoner.dataset.isLeader = 'false'; // 초기 리더 상태 (풀에선 리더 아님)
                commonSummonersPool.appendChild(summoner); // 풀에 소환수 요소 추가

                summoner.addEventListener('dragstart', dragStart); // 드래그 시작 이벤트 리스너 연결
            }
        }

        /**
         * 배치 그리드에 있는 소환수 요소에 'L'(리더 지정) 및 'X'(제거) 버튼을 추가합니다.
         * 이 버튼들은 소환수가 풀에서 그리드로 배치될 때 생성됩니다.
         * @param {HTMLElement} summonerElement - 버튼을 추가할 소환수 DOM 요소
         */
        function addSummonerButtons(summonerElement) {
            // 리더 버튼 생성 또는 업데이트
            let leaderBtn = summonerElement.querySelector('.leader-button');
            if (!leaderBtn) {
                leaderBtn = document.createElement('div');
                leaderBtn.classList.add('summoner-button', 'leader-button');
                leaderBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 부모 요소로 클릭 이벤트 전파 방지
                    toggleLeader(summonerElement); // 리더 토글 함수 호출
                });
                summonerElement.appendChild(leaderBtn);
            }
            // 리더 상태에 따라 버튼 텍스트를 '👑' 또는 'L'로 변경
            leaderBtn.textContent = (summonerElement.dataset.isLeader === 'true') ? '👑' : 'L'; 

            // 제거 버튼 생성 또는 업데이트
            let removeBtn = summonerElement.querySelector('.remove-button');
            if (!removeBtn) {
                removeBtn = document.createElement('div');
                removeBtn.classList.add('summoner-button', 'remove-button');
                removeBtn.textContent = 'X';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 부모 요소로 클릭 이벤트 전파 방지
                    removeSummoner(summonerElement); // 소환수 제거 함수 호출
                });
                summonerElement.appendChild(removeBtn);
            }
        }

        /**
         * 소환수 요소에서 'L' 및 'X' 버튼을 제거합니다.
         * 소환수가 그리드에서 제거되어 풀로 돌아갈 때 사용됩니다.
         * @param {HTMLElement} summonerElement - 버튼을 제거할 소환수 DOM 요소
         */
        function removeSummonerButtons(summonerElement) {
            const leaderBtn = summonerElement.querySelector('.leader-button');
            if (leaderBtn) {
                leaderBtn.remove();
            }
            const removeBtn = summonerElement.querySelector('.remove-button');
            if (removeBtn) {
                removeBtn.remove();
            }
        }

        // 현재 드래그 중인 소환수 엘리먼트 (원본 풀 소환수, 배치된 클론 소환수, 전장 소환수)
        let draggedSummoner = null; 
        // 드래그 시작 시, 배치 그리드에 있던 소환수(클론)의 원래 셀 (HTMLElement)을 추적하기 위한 변수
        let originalDragSourceCell = null; 

        /**
         * 드래그 작업이 시작될 때 호출됩니다.
         * 드래그 대상 소환수의 유형을 식별하고, 배치된 소환수일 경우 임시로 DOM에서 제거합니다.
         * @param {Event} e - dragstart 이벤트 객체
         */
        function dragStart(e) {
            draggedSummoner = e.target;
            
            // 만약 드래그 대상이 소환수 이미지 자체일 경우, 부모 소환수 div를 실제 드래그 대상으로 설정
            if (draggedSummoner.tagName === 'IMG') {
                draggedSummoner = draggedSummoner.closest('.summoner, .battlefield-summoner.my-summoner');
                if (!draggedSummoner) return; // 유효한 소환수 div를 찾지 못하면 함수 종료
            }

            // 드래그하는 소환수가 풀에 있는 원본인지, 그리드에 배치된 클론인지 구분
            if (draggedSummoner.parentElement.id === 'common-summoners-pool') {
                draggedSummoner.dataset.isPoolOriginal = 'true'; // 풀에서 온 원본 소환수
                originalDragSourceCell = null; // 풀에서 왔으므로 원래 배치 셀 없음
            } 
            else { 
                draggedSummoner.dataset.isPoolOriginal = 'false'; // 그리드에서 온 클론 소환수
                // 배치된 소환수를 드래그할 경우, 원래 있던 셀을 저장하여 나중에 복구 또는 교환에 사용
                originalDragSourceCell = draggedSummoner.parentElement;
            }

            // 0.5초 후 드래그 중인 소환수를 반투명하게 만들고, 원래 셀에서 임시 제거
            setTimeout(() => {
                draggedSummoner.style.opacity = '0.5';
                
                // 그리드에서 온 소환수일 경우에만 원래 셀에서 제거하여 드롭 공간을 비워줌
                if (originalDragSourceCell) { 
                    originalDragSourceCell.removeChild(draggedSummoner);
                }
            }, 0);
        }

        /**
         * 드래그 중인 요소가 드롭 가능한 대상 위로 이동할 때 호출됩니다.
         * 브라우저의 기본 드롭 동작을 방지하여 드롭을 허용합니다.
         * @param {Event} e - dragover 이벤트 객체
         */
        function dragOver(e) {
            e.preventDefault(); 
        }

        /**
         * 드래그 중인 요소가 드롭 대상 위에 놓일 때 호출됩니다.
         * 소환수 배치, 이동, 교환, 제거 등의 복잡한 로직을 처리합니다.
         * @param {Event} e - drop 이벤트 객체
         * @param {string} targetGridType - 드롭 대상 그리드의 유형 ('my' 또는 'opponent')
         */
        function drop(e, targetGridType) {
            e.preventDefault(); 
            if (!draggedSummoner) return; // 유효한 드래그 대상이 없으면 함수 종료

            const targetCell = e.target.closest('.grid-cell'); // 드롭된 곳이 그리드 셀인지 확인
            const draggedIsPoolOriginal = draggedSummoner.dataset.isPoolOriginal === 'true'; // 드래그 대상이 풀의 원본인지 여부

            // 1. 드롭 대상이 그리드 셀이 아닌 곳인 경우 (소환수 제거 또는 원본 복구)
            if (!targetCell) { 
                if (!draggedIsPoolOriginal) { // 배치된 클론 소환수를 그리드 밖으로 드롭한 경우
                    removeSummonerFromGrid(draggedSummoner); // 배치 수 감소 및 리더 해제 (DOM 제거는 이 함수에서 하지 않음)
                    draggedSummoner.remove(); // 클론이므로 DOM에서 완전히 제거
                } else { // 풀의 원본 소환수를 그리드 밖으로 드롭한 경우 (풀로 돌아가야 함)
                    draggedSummoner.style.opacity = '1'; // 투명도 복구
                    draggedSummoner.removeAttribute('data-is-pool-original'); // 임시 데이터 제거
                }
                // 드롭 결과에 따른 UI 및 전장 업데이트
                draggedSummoner = null;
                originalDragSourceCell = null; // 원래 셀 정보 초기화
                updateLeaderMarkers();
                updatePlacementCountDisplays(); // N/15 카운트 업데이트
                updateBattlefield(); // 전장 그리드 업데이트
                isDirty = true; // 변경사항 발생
                return; // 함수 종료
            }
            
            const willBeOpponent = (targetGridType === 'opponent'); // 드롭될 그리드의 진영
            let summonerToPlace = draggedSummoner; // 최종적으로 타겟 셀에 배치될 소환수 엘리먼트

            // 2. 풀에서 그리드로 새로운 소환수를 배치하는 경우 (드래그 대상이 풀의 원본)
            if (draggedIsPoolOriginal) { 
                const currentPlacedCount = willBeOpponent ? opponentPlacedSummoners : myPlacedSummoners;
                if (currentPlacedCount >= maxSummoners) { // 해당 진영의 최대 배치 수 초과 확인
                    showToast(`더 이상 소환수를 배치할 수 없습니다. (최대 ${maxSummoners}마리)`);
                    draggedSummoner.style.opacity = '1';
                    draggedSummoner.removeAttribute('data-is-pool-original');
                    draggedSummoner = null;
                    return;
                }

                // 동일 그리드 내 같은 소환수 중복 배치 금지
                const targetGrid = targetGridType === 'my' ? myGrid : opponentGrid;
                const existingSummonerNamesInGrid = Array.from(targetGrid.querySelectorAll('.summoner.is-placed')).map(s => s.dataset.summonerName);
                if (existingSummonerNamesInGrid.includes(draggedSummoner.dataset.summonerName)) {
                    showToast(`"${draggedSummoner.dataset.summonerName}" 소환수는 이미 이 그리드에 배치되어 있습니다.`);
                    draggedSummoner.style.opacity = '1';
                    draggedSummoner.removeAttribute('data-is-pool-original');
                    draggedSummoner = null;
                    return;
                }
                
                // 새로운 클론 생성 및 속성 설정
                summonerToPlace = draggedSummoner.cloneNode(true); // 원본 소환수로부터 클론 생성
                summonerToPlace.classList.remove('summoner-draggable');
                summonerToPlace.classList.add('is-placed'); // 배치된 소환수임을 표시
                summonerToPlace.removeAttribute('id'); // 클론이므로 ID 제거 (HTML ID는 고유해야 함)
                summonerToPlace.setAttribute('draggable', true); // 클론도 드래그 가능하도록 설정
                summonerToPlace.addEventListener('dragstart', dragStart); // 클론에 dragstart 이벤트 리스너 재연결
                summonerToPlace.dataset.isLeader = 'false'; // 새로 배치되는 소환수는 초기 리더 아님
                summonerToPlace.dataset.isOpponent = willBeOpponent.toString(); // 진영 설정
                
                // 새로운 배치이므로 해당 진영의 소환수 카운트 증가
                if (willBeOpponent) {
                    opponentPlacedSummoners++;
                } else {
                    myPlacedSummoners++;
                }

                draggedSummoner.style.opacity = '1'; // 원본 소환수 투명도 복구
                draggedSummoner.removeAttribute('data-is-pool-original'); // 임시 데이터 제거

            } else { // 3. 그리드에서 그리드로 이동 또는 교환 (드래그 대상이 이미 배치된 클론 소환수)
                const draggedSummonerIsOpponent = summonerToPlace.dataset.isOpponent === 'true'; // 드래그한 소환수의 현재 진영
                const originalGridWasOpponent = (originalDragSourceCell && originalDragSourceCell.parentElement.id === 'opponent-grid'); // 드래그 전 소환수의 진영
                
                // 대상 셀에 이미 소환수가 있는 경우 (교환)
                if (targetCell.hasChildNodes()) { 
                    const existingSummoner = targetCell.firstChild; // 대상 셀의 기존 소환수
                    const existingIsOpponent = existingSummoner.dataset.isOpponent === 'true'; // 기존 소환수의 진영

                    if (draggedSummonerIsOpponent === existingIsOpponent) { // 같은 진영 소환수끼리만 교환 허용
                        // 기존 소환수(existingSummoner)를 드래그한 소환수(summonerToPlace)의 원래 위치로 옮김
                        if (originalDragSourceCell) { // dragStart 시 원래 셀이 저장되어 있다면
                             originalDragSourceCell.appendChild(existingSummoner); // 기존 소환수를 원래 자리로 이동
                             existingSummoner.style.opacity = '1'; // 투명도 복구
                             addSummonerButtons(existingSummoner); // 버튼 다시 추가
                        } else { // 원래 셀을 찾을 수 없는 비상 상황 (발생해서는 안되지만, 안전장치)
                            // 이 경우는 교환이 아니므로, 기존 소환수는 제거하고 카운트를 줄여야 함
                            removeSummonerFromGrid(existingSummoner); // 카운트 감소, 리더 해제 (existingSummoner는 사라짐)
                            existingSummoner.remove(); // DOM에서 제거
                        }
                        // 교환이므로 배치된 소환수 총 개수에는 변경 없음.
                    } else { // 다른 진영 소환수와는 교환 불가
                        showToast('다른 진영의 소환수와는 교환할 수 없습니다.');
                        // 드래그한 소환수(summonerToPlace)를 원래 위치(originalDragSourceCell)로 복구
                        if (originalDragSourceCell) { // dragStart 시 원래 셀이 저장되어 있다면
                             originalDragSourceCell.appendChild(summonerToPlace);
                        }
                        summonerToPlace.style.opacity = '1'; // 투명도 복구
                        addSummonerButtons(summonerToPlace); // 버튼 다시 추가
                        // 드롭 실패 시 변수 초기화 및 UI 업데이트 후 함수 종료
                        draggedSummoner = null;
                        originalDragSourceCell = null;
                        updateLeaderMarkers();
                        updatePlacementCountDisplays();
                        updateBattlefield();
                        return; // 교환 실패 시 함수 종료
                    }
                } else { // 대상 셀이 빈 경우 (이동)
                    // 진영 변경이 있는 경우에만 소환수 카운트 및 리더 정보 업데이트 (같은 그리드 내 이동은 카운트 불변)
                    if (originalGridWasOpponent !== willBeOpponent) { 
                        if (originalGridWasOpponent) { // 상대 그리드에서 나의 그리드로 이동
                            opponentPlacedSummoners--;
                            myPlacedSummoners++;
                        } else { // 나의 그리드에서 상대 그리드로 이동
                            myPlacedSummoners--;
                            opponentPlacedSummoners++;
                        }
                        // 리더도 해당 진영에서 해제 (이동한 소환수가 리더였다면)
                        if (opponentLeaderSummoner === summonerToPlace) opponentLeaderSummoner = null;
                        if (myLeaderSummoner === summonerToPlace) myLeaderSummoner = null;
                        
                        summonerToPlace.classList.remove('is-leader'); // 리더 상태 클래스 제거
                        summonerToPlace.dataset.isLeader = 'false'; // 리더 데이터 속성 업데이트
                    }
                }
                // 드래그한 소환수의 소유자 업데이트 (진영 변경이 있었다면)
                summonerToPlace.dataset.isOpponent = willBeOpponent.toString(); 
            }

            // 최종적으로 모든 드롭 시나리오의 성공적인 끝에서 소환수를 타겟 셀에 추가
            targetCell.appendChild(summonerToPlace);
            summonerToPlace.style.opacity = '1'; // 투명도 복구
            addSummonerButtons(summonerToPlace); // 버튼 다시 추가

            // 모든 드롭 시나리오 처리 완료 후 전역 변수 초기화 및 UI 업데이트
            draggedSummoner = null;
            originalDragSourceCell = null; 
            updateLeaderMarkers();
            updatePlacementCountDisplays(); // N/15 카운트 업데이트
            updateBattlefield(); // 전장 그리드 업데이트
            isDirty = true; // 변경사항 발생
        }

        /**
         * 배치된 소환수를 그리드에서 제거하고 풀로 되돌립니다.
         * 주로 'X' 버튼 클릭 시 호출됩니다.
         * @param {HTMLElement} summonerElement - 제거할 소환수 DOM 요소 (클론)
         */
        function removeSummoner(summonerElement) {
            const parentCell = summonerElement.parentElement;
            if (parentCell && parentCell.classList.contains('grid-cell')) { // 소환수가 그리드 셀에 실제로 있다면
                removeSummonerFromGrid(summonerElement); // 배치 수 감소 및 리더 정보 업데이트
                summonerElement.remove(); // 클론이므로 DOM에서 완전히 제거
                
                // 제거 후 UI 업데이트
                updateLeaderMarkers();
                updatePlacementCountDisplays(); // N/15 카운트 업데이트
                updateBattlefield(); // 전장 그리드 업데이트
                isDirty = true; // 변경사항 발생
            }
        }

        /**
         * 그리드에서 소환수(클론)가 완전히 제거될 때 호출되어 배치 수 및 리더 정보를 업데이트합니다.
         * (DOM에서 실제 요소를 제거하는 역할은 이 함수를 호출하는 곳에서 수행합니다.)
         * @param {HTMLElement} summonerElement - 제거될 소환수 DOM 요소
         */
        function removeSummonerFromGrid(summonerElement) {
            const isOpponent = summonerElement.dataset.isOpponent === 'true';
            if (isOpponent) { // 상대편 소환수라면
                opponentPlacedSummoners--; // 상대편 배치 수 감소
                if (opponentLeaderSummoner === summonerElement) { // 제거되는 소환수가 리더였다면
                    opponentLeaderSummoner = null; // 리더 해제
                }
            } else { // 나의 소환수라면
                myPlacedSummoners--; // 나의 배치 수 감소
                if (myLeaderSummoner === summonerElement) { // 제거되는 소환수가 리더였다면
                    myLeaderSummoner = null; // 리더 해제
                }
            }
            summonerElement.dataset.isLeader = 'false'; // 데이터 속성도 리더 해제로 업데이트
        }

        /**
         * 소환수를 해당 진영의 리더로 지정하거나, 이미 리더인 경우 해제합니다.
         * 'L' 버튼 클릭 시 호출됩니다.
         * @param {HTMLElement} summonerElement - 리더 상태를 변경할 소환수 DOM 요소
         */
        function toggleLeader(summonerElement) {
            const isOpponent = summonerElement.dataset.isOpponent === 'true';
            let currentLeader = isOpponent ? opponentLeaderSummoner : myLeaderSummoner;

            // 소환수가 그리드에 배치되어 있지 않으면 리더 지정 불가
            if (!summonerElement.parentElement.classList.contains('grid-cell')) {
                return; 
            }

            if (summonerElement.dataset.isLeader === 'true') {
                // 이미 리더인 경우: 리더 상태를 해제합니다.
                summonerElement.dataset.isLeader = 'false';
                if (isOpponent) {
                    opponentLeaderSummoner = null;
                } else {
                    myLeaderSummoner = null;
                }
            } else {
                // 리더가 아닌 경우: 해당 소환수를 리더로 지정합니다.
                // 이전에 리더였던 소환수가 있다면 그 소환수의 리더 상태를 해제합니다.
                if (currentLeader) {
                    currentLeader.dataset.isLeader = 'false'; // 기존 리더 해제
                }
                summonerElement.dataset.isLeader = 'true'; // 새 소환수를 리더로 설정
                if (isOpponent) {
                    opponentLeaderSummoner = summonerElement;
                } else {
                    myLeaderSummoner = summonerElement;
                }
            }
            // 리더 상태 변경 후 UI 업데이트
            updateLeaderMarkers(); // 리더 마커(왕관/L) 업데이트
            updateBattlefield(); // 전장 그리드 업데이트 (리더 위치 반영)
            isDirty = true; // 변경사항 발생
        }

        /**
         * 배치 그리드에 있는 소환수들의 리더 표시 (테두리, 버튼 텍스트)를 업데이트합니다.
         */
        function updateLeaderMarkers() {
            // 모든 배치된 소환수에서 리더 테두리 제거 및 버튼 텍스트 'L'로 초기화
            document.querySelectorAll('.grid-cell .summoner').forEach(s => {
                s.classList.remove('is-leader'); // 리더 테두리 클래스 제거

                const leaderBtn = s.querySelector('.leader-button');
                if (leaderBtn) {
                    leaderBtn.textContent = 'L'; // 기본 'L' 텍스트로 복구
                }
            });

            // 현재 리더로 지정된 소환수에게 리더 테두리 추가 및 버튼 텍스트 '👑'으로 변경
            [myLeaderSummoner, opponentLeaderSummoner].forEach(leader => {
                // 리더가 존재하고 아직 배치 그리드에 있다면 (유효성 검사)
                if (leader && leader.parentElement && leader.parentElement.classList.contains('grid-cell')) {
                    leader.classList.add('is-leader'); // 리더 테두리 클래스 추가
                    const leaderBtn = leader.querySelector('.leader-button');
                    if (leaderBtn) {
                        leaderBtn.textContent = '👑'; // 왕관 이모지로 변경
                    }
                }
            });
        }

        /**
         * 배치 수 UI (N/15)를 현재 배치된 소환수 수에 맞춰 업데이트합니다.
         */
        function updatePlacementCountDisplays() {
            myGridCountDisplay.textContent = `${myPlacedSummoners}/${maxSummoners}`;
            opponentGridCountDisplay.textContent = `${opponentPlacedSummoners}/${maxSummoners}`;
        }

        /**
         * 전장 그리드를 새로고침하여 현재 배치된 소환수들을 정확한 위치에 표시합니다.
         * 소환수 개수에 따라 전장 셀의 내부 그리드 템플릿과 소환수 크기가 동적으로 변경됩니다.
         */
        function updateBattlefield() {
            battlefieldGrid.innerHTML = ''; // 기존 전장 그리드 내용을 모두 지움
            createBattlefieldGrid(); // 비어있는 전장 그리드 셀들을 다시 생성

            const battlefieldCells = battlefieldGrid.querySelectorAll('.battlefield-cell');
            
            // 전장 중앙의 공유 영역 셀에 배경색을 다시 적용
            for (let r = 0; r < battlefieldRows; r++) {
                for (let c = myLeaderBattlefieldCol + 1; c < opponentLeaderBattlefieldCol; c++) { 
                     const battlefieldIndex = r * battlefieldCols + c;
                     if (battlefieldCells[battlefieldIndex]) {
                         battlefieldCells[battlefieldIndex].classList.add('shared-column');
                     }
                }
            }

            // 나의 배치 그리드와 상대편 배치 그리드에서 소환수 데이터를 수집합니다.
            const myPlacedSummonersData = collectSummonersData(myGrid);
            const opponentPlacedSummonersData = collectSummonersData(opponentGrid);

            // 각 진영의 리더 소환수의 원래 배치 그리드 내 위치를 찾습니다.
            let myLeaderOriginalPos = myPlacedSummonersData.find(s => s.isLeader);
            let opponentLeaderOriginalPos = opponentPlacedSummonersData.find(s => s.isLeader);

            // 전장 셀별로 배치될 소환수들을 매핑하기 위한 Map (예: "행,열" 문자열 키에 소환수 엘리먼트 배열 저장)
            const battlefieldPlacementMap = new Map();

            // 나의 소환수들을 전장 좌표에 매핑하여 Map에 추가
            // 리더가 존재하고 배치되어 있다면, 먼저 리더를 전장 중앙 열에 매핑합니다.
            if (myLeaderSummoner && myLeaderSummoner.parentElement && myLeaderSummoner.parentElement.classList.contains('grid-cell')) {
                const key = `${battlefieldVerticalCenterRow},${myLeaderBattlefieldCol}`;
                if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                battlefieldPlacementMap.get(key).push(myLeaderSummoner);
            }
            // 리더가 아닌 나의 다른 소환수들을 리더를 기준으로 상대적으로 전장 좌표에 매핑합니다.
            myPlacedSummonersData.forEach(data => {
                if (!data.isLeader) { // 리더는 위에서 이미 처리했으므로 건너뜁니다.
                    let bfRow, bfCol;
                    if (myLeaderOriginalPos) { // 리더가 있을 경우: 리더의 전장 위치를 기준으로 상대적 위치를 계산합니다.
                        const rowDiff = data.originalRow - myLeaderOriginalPos.originalRow;
                        const colDiff = data.originalCol - myLeaderOriginalPos.originalCol;
                        bfRow = battlefieldVerticalCenterRow + rowDiff;
                        bfCol = myLeaderBattlefieldCol + colDiff;
                    } else { // 리더가 없을 경우: 나의 그리드 시작점 (전장 2행, 0열) 기준으로 매핑합니다.
                        bfRow = battlefieldVerticalCenterRow - 2 + data.originalRow;
                        bfCol = 0 + data.originalCol; 
                    }
                    // 계산된 전장 좌표가 유효한 범위 내에 있는지 확인 후 Map에 추가합니다.
                    if (bfRow >= 0 && bfRow < battlefieldRows && bfCol >= 0 && bfCol < battlefieldCols) {
                        const key = `${bfRow},${bfCol}`;
                        if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                        battlefieldPlacementMap.get(key).push(data.summoner);
                    }
                }
            });

            // 상대편 소환수들을 전장 좌표에 매핑하여 Map에 추가 (180도 회전 적용)
            // 리더가 존재하고 배치되어 있다면, 먼저 리더를 전장 중앙 열에 매핑합니다.
            if (opponentLeaderSummoner && opponentLeaderSummoner.parentElement && opponentLeaderSummoner.parentElement.classList.contains('grid-cell')) {
                const key = `${battlefieldVerticalCenterRow},${opponentLeaderBattlefieldCol}`;
                if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                battlefieldPlacementMap.get(key).push(opponentLeaderSummoner);
            }
            // 리더가 아닌 상대편의 다른 소환수들을 리더를 기준으로 상대적으로 매핑합니다 (180도 회전 적용).
            opponentPlacedSummonersData.forEach(data => {
                if (!data.isLeader) { 
                    let bfRow, bfCol;
                    // 배치 그리드 내에서 180도 회전된 상대적 위치를 계산합니다.
                    const rotatedRow = (grid5x5Size - 1) - data.originalRow;
                    const rotatedCol = (grid5x5Size - 1) - data.originalCol;

                    if (opponentLeaderOriginalPos) { // 리더가 있을 경우: 리더의 회전된 위치를 기준으로 상대적 위치를 계산합니다.
                        const leaderRotatedRow = (grid5x5Size - 1) - opponentLeaderOriginalPos.originalRow;
                        const leaderRotatedCol = (grid5x5Size - 1) - opponentLeaderOriginalPos.originalCol;

                        const rowDiff = rotatedRow - leaderRotatedRow;
                        const colDiff = rotatedCol - leaderRotatedCol;
                        
                        bfRow = battlefieldVerticalCenterRow + rowDiff;
                        bfCol = opponentLeaderBattlefieldCol + colDiff;

                    } else { // 리더가 없을 경우: 상대 그리드 시작점 (전장 2행, 8열) 기준으로 매핑 (회전된 좌표 사용)
                        bfRow = battlefieldVerticalCenterRow - 2 + rotatedRow;
                        bfCol = 8 + rotatedCol; 
                    }
                    // 계산된 전장 좌표가 유효한 범위 내에 있는지 확인 후 Map에 추가합니다.
                    if (bfRow >= 0 && bfRow < battlefieldRows && bfCol >= 0 && bfCol < battlefieldCols) {
                        const key = `${bfRow},${bfCol}`;
                        if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                        battlefieldPlacementMap.get(key).push(data.summoner);
                    }
                }
            });

            // Map에 매핑된 데이터를 기반으로 실제 전장 셀에 소환수들을 배치합니다.
            battlefieldPlacementMap.forEach((summonersInCell, key) => {
                const [rowStr, colStr] = key.split(',');
                const bfRow = parseInt(rowStr);
                const bfCol = parseInt(colStr);
                const battlefieldIndex = bfRow * battlefieldCols + bfCol;
                const bfCell = battlefieldCells[battlefieldIndex];

                // 셀에 있는 소환수 수에 따라 battlefield-cell의 내부 그리드 템플릿을 동적으로 변경합니다.
                if (summonersInCell.length === 1) {
                    bfCell.classList.remove('multi-summoners'); // 2개 이상일 때 적용되는 클래스 제거
                    bfCell.classList.remove('three-plus'); // 3개 이상일 때 적용되는 클래스 제거
                    bfCell.style.gridTemplateColumns = '1fr'; // 1x1 그리드 유지
                    bfCell.style.gridTemplateRows = '1fr';
                } else if (summonersInCell.length === 2) {
                    bfCell.classList.add('multi-summoners'); // 2개일 때: 가로 2분할, 세로 1칸 그리드 활성화
                    bfCell.classList.remove('three-plus'); // 3개 이상일 때 적용되는 클래스 제거
                    bfCell.style.gridTemplateColumns = 'repeat(2, 1fr)'; 
                    bfCell.style.gridTemplateRows = '1fr'; 
                } else { /* summonersInCell.length >= 3 */
                    bfCell.classList.add('multi-summoners'); // 3개 이상일 때: 가로 2분할, 세로 2분할 그리드 활성화
                    bfCell.classList.add('three-plus'); // 2x2 그리드 클래스 추가
                    bfCell.style.gridTemplateColumns = 'repeat(2, 1fr)'; 
                    bfCell.style.gridTemplateRows = 'repeat(2, 1fr)'; 
                }

                // 2x2 그리드 내에서 소환수 배치 위치를 정의합니다 (좌상, 우상, 좌하, 우하).
                const positions2x2 = [[1,1], [1,2], [2,1], [2,2]]; 
                
                // 해당 셀에 배치될 소환수들을 순회하며 실제 DOM 요소를 생성하고 추가합니다.
                summonersInCell.forEach((summonerElement, index) => {
                    // 최대 4마리까지만 표시합니다 (2x2 그리드 최대).
                    if (index < positions2x2.length) { 
                        const bfSummoner = document.createElement('div');
                        bfSummoner.classList.add('battlefield-summoner'); // 전장 소환수 기본 스타일
                        // 소환수 진영에 따라 배경색 클래스 추가
                        bfSummoner.classList.add(summonerElement.dataset.isOpponent === 'true' ? 'opponent-summoner' : 'my-summoner');
                        
                        // 소환수 수에 따라 다른 크기 클래스 부여 및 내부 그리드 위치 지정
                        if (summonersInCell.length === 1) {
                            bfSummoner.classList.add('single-summoner'); // 1마리일 때 큰 크기
                            bfSummoner.style.gridRowStart = '1';
                            bfSummoner.style.gridColumnStart = '1';
                        } else if (summonersInCell.length === 2) {
                            bfSummoner.classList.add('multi-summoner'); // 2마리일 때 중간 크기
                            bfSummoner.style.gridRowStart = '1'; // 1행 고정
                            bfSummoner.style.gridColumnStart = index + 1; // 1열, 2열에 배치 (가로로 나란히)
                        } else { // 3마리 이상: 2x2 그리드에 배치될 때 작은 크기
                            bfSummoner.classList.add('multi-summoner');
                            bfSummoner.style.gridRowStart = positions2x2[index][0];
                            bfSummoner.style.gridColumnStart = positions2x2[index][1];
                        }

                        // 이미지 태그를 생성하여 소환수 내부에 추가합니다.
                        const img = document.createElement('img');
                        img.src = `${imagePath}${summonerElement.dataset.summonerName}${imageExtension}`;
                        img.alt = summonerElement.dataset.summonerName;
                        bfSummoner.appendChild(img);
                        
                        // 리더 소환수에게 왕관 마커를 추가합니다.
                        if (summonerElement.dataset.isLeader === 'true') {
                            const leaderMarker = document.createElement('span');
                            leaderMarker.classList.add('battlefield-leader-marker');
                            leaderMarker.textContent = '👑';
                            bfSummoner.appendChild(leaderMarker);
                        }
                        bfCell.appendChild(bfSummoner); // 최종적으로 전장 셀에 소환수 추가
                    }
                });
            });
        }

        /**
         * 지정된 배치 그리드에서 현재 배치된 소환수들의 데이터를 수집합니다.
         * 각 소환수의 이름, 리더 여부, 원래 그리드 내 상대적 위치 등을 포함합니다.
         * @param {HTMLElement} gridElement - 데이터를 수집할 그리드 DOM 요소 (myGrid 또는 opponentGrid)
         * @returns {Array<Object>} - 배치된 소환수들의 정보 객체 배열
         */
        function collectSummonersData(gridElement) {
            const placedSummonersData = [];
            gridElement.querySelectorAll('.grid-cell').forEach(gridCell => { 
                if (gridCell.firstChild) { // 셀에 소환수(클론)가 있다면
                    const summoner = gridCell.firstChild; // 클론 소환수 엘리먼트
                    const name = summoner.dataset.summonerName;
                    const isLeader = summoner.dataset.isLeader === 'true';
                    const gridIndex = parseInt(gridCell.dataset.index); // 셀의 인덱스
                    const originalRow = Math.floor(gridIndex / grid5x5Size); // 배치 그리드 내 원래 행
                    const originalCol = gridIndex % grid5x5Size; // 배치 그리드 내 원래 열
                    placedSummonersData.push({ summoner, name, isLeader, originalRow, originalCol, gridIndex });
                }
            });
            return placedSummonersData;
        }

        /**
         * 현재 활성화된 편성에 배치 상태를 저장합니다.
         */
        function saveArrangement() {
            const myData = collectSummonersData(myGrid).map(s => ({
                name: s.name,
                isLeader: s.isLeader,
                gridIndex: s.gridIndex
            }));
            const opponentData = collectSummonersData(opponentGrid).map(s => ({
                name: s.name,
                isLeader: s.isLeader,
                gridIndex: s.gridIndex
            }));

            let allArrangementsData = {};
            try {
                const storedData = localStorage.getItem('summonerAllArrangements');
                if (storedData) {
                    allArrangementsData = JSON.parse(storedData);
                }
            } catch (e) {
                console.error("저장된 전체 편성 데이터를 파싱하는 중 오류 발생:", e);
            }

            // 현재 편성에 데이터 저장
            allArrangementsData[`arrangement_${currentArrangementId}`] = {
                myPlacement: myData,
                opponentPlacement: opponentData
            };
            
            // 사용 가능한 편성 ID 목록 업데이트 및 저장
            if (!availableArrangementIds.includes(currentArrangementId)) {
                availableArrangementIds.push(currentArrangementId);
                availableArrangementIds.sort((a, b) => a - b); // 오름차순 정렬
                localStorage.setItem('availableArrangementIds', JSON.stringify(availableArrangementIds));
            }
            
            try {
                localStorage.setItem('summonerAllArrangements', JSON.stringify(allArrangementsData));
                isDirty = false; // 저장 후 clean 상태로 변경
                showToast(`현재 배치가 '${arrangementNames[currentArrangementId] || `편성 ${currentArrangementId}`}'에 성공적으로 저장되었습니다!`);
            } catch (e) {
                showToast(`편성 ${currentArrangementId}에 저장 실패: ` + e);
            }
        }

        /**
         * 지정된 ID의 편성 상태를 불러옵니다.
         * @param {number} arrangementId - 불러올 편성의 ID
         */
        function loadArrangement(arrangementId) {
            if (isDirty) {
                if (!confirm('저장되지 않은 변경사항이 있습니다. 정말 다른 편성을 불러오시겠습니까? 이 작업은 저장되지 않은 변경사항을 되돌릴 수 없습니다.')) {
                    return;
                }
            }

            currentArrangementId = arrangementId; // 현재 활성화된 편성 ID 업데이트
            updateArrangementButtonActiveState(); // 버튼 활성화 상태 업데이트

            let allArrangementsData = {};
            try {
                const storedData = localStorage.getItem('summonerAllArrangements');
                if (storedData) {
                    allArrangementsData = JSON.parse(storedData);
                }
            } catch (e) {
                console.error("저장된 전체 편성 데이터를 파싱하는 중 오류 발생:", e);
                showToast('저장된 편성 데이터를 불러오는 중 오류가 발생했습니다.');
                return;
            }

            const arrangementData = allArrangementsData[`arrangement_${arrangementId}`];

            // 현재 배치된 모든 소환수 제거 (초기화)
            clearCurrentDisplay(true); // isDirty 플래그를 변경하지 않고 화면만 초기화

            if (!arrangementData || (!arrangementData.myPlacement && !arrangementData.opponentPlacement)) {
                isDirty = false; // 빈 편성을 불러왔으므로 clean 상태
                return;
            }

            const myLoadedData = arrangementData.myPlacement || [];
            const opponentLoadedData = arrangementData.opponentPlacement || [];

            // 나의 소환수 배치
            myLoadedData.forEach(data => {
                const targetCell = myGrid.querySelector(`.grid-cell[data-index="${data.gridIndex}"]`);
                if (targetCell) {
                    const originalSummoner = commonSummonersPool.querySelector(`[data-summoner-name="${data.name}"]`);
                    if (originalSummoner) { // summoner_images 폴더에 해당 이미지가 없을 경우를 대비
                        const newSummoner = originalSummoner.cloneNode(true);
                        newSummoner.classList.remove('summoner-draggable');
                        newSummoner.classList.add('is-placed');
                        newSummoner.removeAttribute('id');
                        newSummoner.setAttribute('draggable', true);
                        newSummoner.addEventListener('dragstart', dragStart);
                        newSummoner.dataset.isLeader = data.isLeader.toString();
                        newSummoner.dataset.isOpponent = 'false'; // 나의 소환수
                        targetCell.appendChild(newSummoner);
                        addSummonerButtons(newSummoner); // 버튼 추가

                        // 로드 시점에 리더 참조 업데이트
                        if (data.isLeader) {
                            myLeaderSummoner = newSummoner;
                        }
                        myPlacedSummoners++;
                    } else {
                        console.warn(`[편성 불러오기] 소환수 이미지를 찾을 수 없습니다: ${data.name}`);
                    }
                }
            });

            // 상대편 소환수 배치
            opponentLoadedData.forEach(data => {
                const targetCell = opponentGrid.querySelector(`.grid-cell[data-index="${data.gridIndex}"]`);
                if (targetCell) {
                    const originalSummoner = commonSummonersPool.querySelector(`[data-summoner-name="${data.name}"]`);
                    if (originalSummoner) { // summoner_images 폴더에 해당 이미지가 없을 경우를 대비
                        const newSummoner = originalSummoner.cloneNode(true);
                        newSummoner.classList.remove('summoner-draggable');
                        newSummoner.classList.add('is-placed');
                        newSummoner.removeAttribute('id');
                        newSummoner.setAttribute('draggable', true);
                        newSummoner.addEventListener('dragstart', dragStart);
                        newSummoner.dataset.isLeader = data.isLeader.toString();
                        newSummoner.dataset.isOpponent = 'true'; // 상대편 소환수
                        targetCell.appendChild(newSummoner);
                        addSummonerButtons(newSummoner); // 버튼 추가

                        // 로드 시점에 리더 참조 업데이트
                        if (data.isLeader) {
                            opponentLeaderSummoner = newSummoner;
                        }
                        opponentPlacedSummoners++;
                    } else {
                        console.warn(`[편성 불러오기] 소환수 이미지를 찾을 수 없습니다: ${data.name}`);
                    }
                }
            });

            updateLeaderMarkers();
            updatePlacementCountDisplays();
            updateBattlefield();
            isDirty = false; // 새로운 편성을 불러왔으므로 clean 상태로 초기화
        }

        /**
         * 현재 화면에 표시된 모든 배치 그리드를 초기화합니다.
         * @param {boolean} silent - true일 경우 isDirty 플래그를 변경하지 않음 (편성 로드 시 내부 사용)
         */
        function clearCurrentDisplay(silent = false) {
            const wasEmpty = myPlacedSummoners === 0 && opponentPlacedSummoners === 0;

            // 나의 그리드 소환수 제거
            myGrid.querySelectorAll('.grid-cell').forEach(cell => {
                if (cell.firstChild) cell.removeChild(cell.firstChild);
            });
            myPlacedSummoners = 0;
            myLeaderSummoner = null;

            // 상대편 그리드 소환수 제거
            opponentGrid.querySelectorAll('.grid-cell').forEach(cell => {
                if (cell.firstChild) cell.removeChild(cell.firstChild);
            });
            opponentPlacedSummoners = 0;
            opponentLeaderSummoner = null;

            // UI 업데이트
            updateLeaderMarkers();
            updatePlacementCountDisplays();
            updateBattlefield();

            if (!silent && !wasEmpty) {
                isDirty = true; // 비어있지 않은 상태에서 클리어했다면 변경사항으로 간주
            }
        }

        /**
         * 현재 활성화된 편성의 저장된 데이터를 지웁니다.
         */
        function clearCurrentArrangementData() {
            if (isDirty) {
                if (!confirm('저장되지 않은 변경사항이 있습니다. 저장하지 않고 현재 편성을 비우시겠습니까?')) {
                    return;
                }
            } else {
                if (!confirm(`정말 현재 편성 '${arrangementNames[currentArrangementId] || `편성 ${currentArrangementId}`}'의 화면 배치를 모두 비우시겠습니까?`)) {
                    return;
                }
            }
            clearCurrentDisplay();
        }

        /**
         * localStorage의 모든 편성 데이터를 지우고, 화면의 배치도 초기화합니다.
         */
        function clearAllArrangements() {
            if (isDirty) {
                if (!confirm('저장되지 않은 변경사항이 있습니다. 저장하지 않고 모든 편성을 초기화하시겠습니까?')) {
                    return;
                }
            } else {
                if (!confirm('정말 모든 저장된 편성 슬롯을 초기화하고 현재 배치도 지우시겠습니까?')) {
                    return;
                }
            }

            try {
                localStorage.removeItem('summonerAllArrangements');
                localStorage.removeItem('availableArrangementIds');
                localStorage.removeItem('summonerArrangementNames');
                localStorage.removeItem('lastActiveArrangementId');
                
                availableArrangementIds = [];
                arrangementNames = {};
                
                showToast('모든 저장된 편성 슬롯이 초기화되었습니다!');
                clearCurrentDisplay(true); // 화면 초기화 (isDirty는 false로)
                renderArrangementButtons(); 
                addInitialArrangement();
                isDirty = false;

            } catch (e) {
                showToast('모든 저장된 편성 초기화에 실패했습니다: ' + e);
            }
        }

        /**
         * 편성 선택 버튼의 활성화 상태를 업데이트합니다.
         */
        function updateArrangementButtonActiveState() {
            document.querySelectorAll('.arrangement-button').forEach(button => {
                if (parseInt(button.dataset.arrangementId) === currentArrangementId) {
                    button.classList.add('active-arrangement');
                } else {
                    button.classList.remove('active-arrangement');
                }
            });
        }

        /**
         * 새로운 편성 슬롯을 추가합니다.
         */
        function addArrangement() {
            if (availableArrangementIds.length >= maxArrangements) {
                showToast(`최대 편성 개수(${maxArrangements}개)에 도달했습니다.`);
                return;
            }

            if (isDirty) {
                if (!confirm('저장되지 않은 변경사항이 있습니다. 저장하지 않고 새로운 편성을 추가하시겠습니까?')) {
                    return;
                }
            }

            // 새로운 편성 ID 찾기 (가장 작은 사용 가능한 양의 정수)
            let newArrangementId = 1;
            while (availableArrangementIds.includes(newArrangementId)) {
                newArrangementId++;
            }
            
            availableArrangementIds.push(newArrangementId);
            availableArrangementIds.sort((a, b) => a - b); // 오름차순 정렬
            localStorage.setItem('availableArrangementIds', JSON.stringify(availableArrangementIds));
            
            renderArrangementButtons(); // 버튼 UI 갱신
            loadArrangement(newArrangementId); 
            showToast(`새로운 편성 ${newArrangementId}이 추가되었습니다.`);
        }

        /**
         * 편성 버튼들을 UI에 렌더링합니다. (추가/삭제 시 호출)
         */
        function renderArrangementButtons() {
            const existingArrangementItems = arrangementButtonsContainer.querySelectorAll('.arrangement-item');
            existingArrangementItems.forEach(item => item.remove());

            availableArrangementIds.forEach(id => {
                const arrangementItem = document.createElement('div');
                arrangementItem.classList.add('arrangement-item');

                const button = document.createElement('button');
                button.classList.add('arrangement-button');
                button.dataset.arrangementId = id;
                button.textContent = arrangementNames[id] || `편성 ${id}`;
                button.addEventListener('click', () => loadArrangement(id));
                arrangementItem.appendChild(button);

                // 이름 변경 버튼 추가
                const renameButton = document.createElement('button');
                renameButton.classList.add('rename-arrangement-button');
                renameButton.innerHTML = '✏️';
                renameButton.title = '이름 변경';
                renameButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    renameArrangement(id);
                });
                arrangementItem.appendChild(renameButton);

                // 삭제 버튼 추가
                const deleteButton = document.createElement('button');
                deleteButton.classList.add('delete-arrangement-button');
                deleteButton.textContent = 'X';
                deleteButton.title = '편성 삭제';
                deleteButton.dataset.arrangementIdToDelete = id;
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    deleteArrangement(id);
                });
                arrangementItem.appendChild(deleteButton);
                
                arrangementButtonsContainer.insertBefore(arrangementItem, addArrangementButton);
            });

            updateArrangementButtonActiveState();
        }

        /**
         * 편성의 이름을 변경합니다.
         * @param {number} arrangementId - 이름을 변경할 편성의 ID
         */
        function renameArrangement(arrangementId) {
            const currentName = arrangementNames[arrangementId] || `편성 ${arrangementId}`;
            const newName = prompt('새로운 편성 이름을 입력하세요:', currentName);

            if (newName && newName.trim() !== '' && newName.trim() !== currentName) {
                arrangementNames[arrangementId] = newName.trim();
                localStorage.setItem('summonerArrangementNames', JSON.stringify(arrangementNames));
                showToast('편성 이름이 변경되었습니다.');
                renderArrangementButtons(); // 버튼 UI 갱신
                isDirty = true; // 이름 변경도 저장 필요한 변경사항으로 간주
            }
        }

        /**
         * 특정 편성 ID의 데이터를 삭제합니다.
         * @param {number} arrangementIdToDelete - 삭제할 편성의 ID
         */
        function deleteArrangement(arrangementIdToDelete) {
            const arrangementName = arrangementNames[arrangementIdToDelete] || `편성 ${arrangementIdToDelete}`;
            if (!confirm(`정말 '${arrangementName}' 편성을 삭제하시겠습니까? (저장된 배치도 함께 삭제됩니다)`)) {
                return;
            }

            // 삭제하려는 편성이 현재 활성화된 편성이고, 변경사항이 있는 경우 한 번 더 확인
            if (isDirty && currentArrangementId === arrangementIdToDelete) {
                if (!confirm('현재 편성에 저장되지 않은 변경사항이 있습니다. 저장하지 않고 삭제하시겠습니까?')) {
                    return;
                }
            }

            // 1. ID 목록에서 제거하고 저장
            availableArrangementIds = availableArrangementIds.filter(id => id !== arrangementIdToDelete);
            localStorage.setItem('availableArrangementIds', JSON.stringify(availableArrangementIds));

            // 2. 이름 목록에서 제거하고 저장
            if (arrangementNames[arrangementIdToDelete]) {
                delete arrangementNames[arrangementIdToDelete];
                localStorage.setItem('summonerArrangementNames', JSON.stringify(arrangementNames));
            }

            // 3. 배치 데이터에서 제거하고 저장
            let allArrangementsData = {};
            try {
                const storedData = localStorage.getItem('summonerAllArrangements');
                if (storedData) {
                    allArrangementsData = JSON.parse(storedData);
                    if (allArrangementsData[`arrangement_${arrangementIdToDelete}`]) {
                        delete allArrangementsData[`arrangement_${arrangementIdToDelete}`];
                        localStorage.setItem('summonerAllArrangements', JSON.stringify(allArrangementsData));
                    }
                }
            } catch (e) {
                console.error("저장된 전체 편성 데이터를 파싱하는 중 오류 발생:", e);
                showToast('저장된 데이터를 읽는 중 오류가 발생했습니다.');
                return; // 여기서 중단
            }

            showToast(`'${arrangementName}' 편성이 성공적으로 삭제되었습니다.`);
            
            renderArrangementButtons(); // 버튼 UI 갱신

            // 삭제된 편성이 현재 활성화된 편성이었다면 다른 편성으로 전환
            if (currentArrangementId === arrangementIdToDelete) {
                isDirty = false; // 삭제했으므로 현재 상태는 clean
                if (availableArrangementIds.length > 0) {
                    loadArrangement(availableArrangementIds[0]); 
                } else {
                    addInitialArrangement();
                }
            } else {
                updateArrangementButtonActiveState();
            }
        }

        /**
         * 최초 로드 시 편성 1이 없으면 자동으로 생성하고 로드합니다.
         */
        function addInitialArrangement() {
            if (availableArrangementIds.length === 0) {
                availableArrangementIds = [1];
                localStorage.setItem('availableArrangementIds', JSON.stringify(availableArrangementIds));
                currentArrangementId = 1;
                renderArrangementButtons();
                loadArrangement(1);
            }
        }

        /**
         * 토스트 메시지를 화면 중앙에 띄우고 1초 뒤 사라지게 합니다.
         * @param {string} message - 표시할 메시지 텍스트
         * @param {number} duration - 메시지가 표시될 시간 (밀리초), 기본값 1000ms
         */
        function showToast(message, duration = 1000) {
            clearTimeout(toastTimeout); 
            toastMessage.textContent = message;
            toastMessage.classList.add('show');
            toastTimeout = setTimeout(() => {
                toastMessage.classList.remove('show');
            }, duration);
        }


        // --- 초기화 로직 ---
        createBattlefieldGrid(); 
        createGrid(myGrid, 'my'); 
        createGrid(opponentGrid, 'opponent'); 
        createCommonSummonerPool(); 

        // 저장된 데이터 불러오기
        const storedArrangementIds = localStorage.getItem('availableArrangementIds');
        const storedArrangementNames = localStorage.getItem('summonerArrangementNames');

        if (storedArrangementNames) {
            try {
                arrangementNames = JSON.parse(storedArrangementNames);
            } catch (e) {
                console.error("저장된 편성 이름 데이터 파싱 오류", e);
                arrangementNames = {};
            }
        }

        if (storedArrangementIds) {
            try {
                availableArrangementIds = JSON.parse(storedArrangementIds);
                if (availableArrangementIds.length > 0) {
                    const lastActiveArrangementId = parseInt(localStorage.getItem('lastActiveArrangementId')) || availableArrangementIds[0];
                    currentArrangementId = availableArrangementIds.includes(lastActiveArrangementId) ? lastActiveArrangementId : availableArrangementIds[0];
                } else {
                    addInitialArrangement();
                }
            } catch (e) {
                 console.error("저장된 편성 ID 데이터 파싱 오류", e);
                 addInitialArrangement();
            }
        } else {
            addInitialArrangement();
        }
        
        addArrangementButton.addEventListener('click', addArrangement);

        renderArrangementButtons();
        
        if (availableArrangementIds.length > 0) {
            loadArrangement(currentArrangementId);
        } else {
            updatePlacementCountDisplays();
            updateBattlefield();
        }

        // 제어 버튼 이벤트 리스너 연결
        document.getElementById('save-arrangement-button').addEventListener('click', saveArrangement);
        document.getElementById('clear-current-arrangement-button').addEventListener('click', clearCurrentArrangementData);
        document.getElementById('clear-all-arrangements-button').addEventListener('click', clearAllArrangements);

        // 페이지를 떠나기 전 변경사항 확인
        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                e.preventDefault(); // 표준에 따라 필요
                e.returnValue = ''; // Chrome에서 필요
            }
            // 현재 활성화된 편성 ID 저장
            if (currentArrangementId !== 0 && availableArrangementIds.length > 0) {
                localStorage.setItem('lastActiveArrangementId', currentArrangementId.toString());
            } else {
                localStorage.removeItem('lastActiveArrangementId');
            }
        });

    </script>
</body>
</html>
