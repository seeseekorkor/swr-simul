<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†Œí™˜ìˆ˜ ë°°ì¹˜ ì‹œë®¬ë ˆì´ì…˜</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        /* ì „ì¥ ê·¸ë¦¬ë“œ ìŠ¤íƒ€ì¼ (ì œì¼ ìœ„) */
        .battlefield-container {
            display: grid;
            grid-template-columns: repeat(17, 60px);
            grid-template-rows: repeat(9, 60px);
            gap: 2px;
            border: 2px solid #666;
            width: fit-content;
            margin-bottom: 30px;
            background-color: #e0ffe0;
        }
        .battlefield-cell {
            width: 60px;
            height: 60px;
            border: 1px dotted #aaa;
            display: grid; 
            grid-template-columns: 1fr; 
            grid-template-rows: 1fr;
            gap: 0;
            font-size: 8px; /* ì´ë¯¸ì§€ê°€ í…ìŠ¤íŠ¸ ëŒ€ì²´í•˜ë¯€ë¡œ ì¤‘ìš”ë„ ë‚®ì•„ì§ */
            position: relative;
            box-sizing: border-box;
            overflow: hidden; 
        }
        .battlefield-cell.multi-summoners {
            grid-template-columns: repeat(2, 1fr); 
            grid-template-rows: 1fr; /* 2ê°œì¼ ë•Œ ì„¸ë¡œëŠ” 100% ì‚¬ìš© */
        }
        .battlefield-cell.shared-column {
            background-color: #d0d0ff;
        }
        
        /* .battlefield-summoner ì´ì œ ì´ë¯¸ì§€ë¥¼ í¬í•¨ */
        .battlefield-summoner {
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white; /* í…ìŠ¤íŠ¸ ìƒ‰ìƒ (ì´ë¦„ ì—†ìœ¼ë©´ ì˜ë¯¸ ì—†ìŒ) */
            font-weight: bold;
            font-size: 8px; /* í…ìŠ¤íŠ¸ í¬ê¸° (ì´ë¦„ ì—†ìœ¼ë©´ ì˜ë¯¸ ì—†ìŒ) */
            text-align: center;
            line-height: 1;
            padding: 1px;
            box-sizing: border-box;
            margin: 0; 
            overflow: hidden; /* ì´ë¯¸ì§€ ë„˜ì¹¨ ë°©ì§€ */
        }
        .battlefield-summoner img {
            width: 100%; /* ë¶€ëª¨(battlefield-summoner) í¬ê¸°ì— ë§ì¶¤ */
            height: 100%; /* ë¶€ëª¨(battlefield-summoner) í¬ê¸°ì— ë§ì¶¤ */
            object-fit: cover; /* ì´ë¯¸ì§€ê°€ ì˜ë¦¬ì§€ ì•Šê³  ì±„ì›Œì§€ë„ë¡ */
            border-radius: 3px; /* ì†Œí™˜ìˆ˜ í…Œë‘ë¦¬ ë°˜ê²½ê³¼ ì¼ì¹˜ */
        }

        /* ì „ì¥ ì†Œí™˜ìˆ˜: 1ë§ˆë¦¬ì¼ ë•Œ (ì…€ ì „ì²´ ì‚¬ìš©) */
        .battlefield-summoner.single-summoner {
            width: calc(100% - 2px); 
            height: calc(100% - 2px); 
            margin: 1px; 
        }
        /* ì „ì¥ ì†Œí™˜ìˆ˜: 2ë§ˆë¦¬ ì´ìƒì¼ ë•Œ (í•˜ìœ„ 2ì—´ ê·¸ë¦¬ë“œ ì‚¬ìš©) */
        .battlefield-summoner.multi-summoner {
            width: calc(100% - 2px); 
            height: calc(100% - 2px); 
            margin: 1px; 
        }

        .battlefield-summoner.my-summoner {
            background-color: #2196F3; /* ë°°ê²½ìƒ‰ì€ ì—¬ì „íˆ ì†Œìœ ì êµ¬ë¶„ìš©ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒ */
        }
        .battlefield-summoner.opponent-summoner {
            background-color: #f44336;
        }
        .battlefield-leader-marker {
            position: absolute;
            top: 1px;
            right: 1px;
            font-size: 7px;
            color: gold;
            text-shadow: 0.5px 0.5px 1px rgba(0,0,0,0.7);
        }

        /* ë°°ì¹˜ ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆ (ì¤‘ê°„, ì¢Œìš° ë¶„í• ) */
        .placement-section {
            display: flex;
            width: 100%;
            justify-content: center;
            gap: 50px;
            margin-bottom: 30px;
        }

        .grid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            grid-template-rows: repeat(5, 60px);
            gap: 5px;
            border: 2px solid #333;
            width: fit-content;
        }
        .grid-cell {
            width: 60px;
            height: 60px;
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: default;
            background-color: #f0f0f0;
            position: relative;
        }
        /* .summoner ê¸°ë³¸ ìŠ¤íƒ€ì¼ (í’€, ë°°ì¹˜ ê·¸ë¦¬ë“œ) - ì´ë¯¸ì§€ í¬í•¨ë˜ë„ë¡ ë³€ê²½ */
        .summoner {
            width: 50px; 
            height: 50px; 
            background-color: #4CAF50; 
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 10px;
            text-align: center;
            line-height: 1.2;
            padding: 2px;
            box-sizing: border-box;
            position: relative;
            overflow: hidden; /* ì´ë¯¸ì§€ ë„˜ì¹¨ ë°©ì§€ */
        }
        .summoner img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 5px; /* ì†Œí™˜ìˆ˜ í…Œë‘ë¦¬ ë°˜ê²½ê³¼ ì¼ì¹˜ */
        }

        .summoner-draggable {
            cursor: grab;
            margin: 5px;
            background-color: #4CAF50;
        }
        .summoner[data-is-opponent="false"].is-placed {
            background-color: #2196F3;
        }
        .summoner[data-is-opponent="true"].is-placed {
            background-color: #f44336;
        }

        .is-leader {
            border: 3px solid gold; 
            box-shadow: 0 0 10px gold;
        }
        .summoner-button {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
        }
        .leader-button {
            top: -5px;
            left: -5px;
            background-color: #ffd700;
            color: #333;
            border: 1px solid #ccaa00;
        }
        .leader-button:hover {
            background-color: #ffeb3b;
        }
        .remove-button {
            top: -5px;
            right: -5px;
            background-color: #f44336;
            color: white;
            border: 1px solid #d32f2f;
        }
        .remove-button:hover {
            background-color: #ef5350;
        }

        .summoners-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            border: 1px solid #eee;
            padding: 10px;
            width: 1000px;
            justify-content: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>ì†Œí™˜ìˆ˜ ë°°ì¹˜ ì‹œë®¬ë ˆì´ì…˜</h1>

    <h2>ì „ì¥</h2>
    <div id="battlefield-grid" class="battlefield-container">
        </div>

    <div class="placement-section">
        <div class="grid-wrapper">
            <h2>ë‚˜ì˜ ë°°ì¹˜</h2>
            <div id="my-grid" class="grid-container">
                </div>
        </div>

        <div class="grid-wrapper">
            <h2>ìƒëŒ€í¸ ë°°ì¹˜</h2>
            <div id="opponent-grid" class="grid-container">
                </div>
        </div>
    </div>

    <hr>

    <h3>ì†Œí™˜ìˆ˜ ëª©ë¡ (í’€ì—ì„œ ë“œë˜ê·¸í•˜ì—¬ ë°°ì¹˜)</h3>
    <div id="common-summoners-pool" class="summoners-pool">
        </div>

    <script>
        const opponentGrid = document.getElementById('opponent-grid');
        const myGrid = document.getElementById('my-grid');
        const commonSummonersPool = document.getElementById('common-summoners-pool');
        const battlefieldGrid = document.getElementById('battlefield-grid');

        const grid5x5Size = 5;
        const maxSummoners = 15;

        const battlefieldCols = 17;
        const battlefieldRows = 9;   
        
        const battlefieldVerticalCenterRow = Math.floor(battlefieldRows / 2); 

        const myLeaderBattlefieldCol = 4; 
        const opponentLeaderBattlefieldCol = 12;

        const summonerNames = [
            'ì‚¬ë¸Œë¦¬ë‚˜', 'í…Œì‚¬ë¦¬ì˜¨', 'ì•„ë¥´íƒ€ë¯¸ì—˜', 'íˆ¬ì „ìŠ¹ë¶ˆ', 'ë¼ì´ë§ˆ', 'ë©œë¦¬ì‚¬', 'ì¹´ì‚°ë“œë¼', 
            'ìƒ¬ë¡¯', 'ì• ë„ˆë²¨', 'ì”ëŠ', 'ì‹œí™”', 'ê·¸ë¡œê²', 'ë¦¬ë‚˜', 'ë¸í¬ì´', 'ì˜¤í•„ë¦¬ì•„', 
            'ë°”ë„¤ì‚¬', 'í’ì—°', 'ë² ë¥´ë°í•˜ì¼', 'ë£¨ì‰”', 'ì…€ë ˆìŠ¤í‹°ì•„', 'ì•„ì´ë¦¬ì—˜', 'ë¼í”¼ìŠ¤', 
            'ì•Œë¦¬ì‹œì•„', 'í…ŒíŠ¸ë¼', 'ì±„ì„ ', 'ê°¤ë¦¬ì˜¨', 'ë¯¸í›„ì™•'
        ].sort();

        // ì´ë¯¸ì§€ íŒŒì¼ì´ ìˆëŠ” í´ë” ê²½ë¡œ (HTML íŒŒì¼ê³¼ ê°™ì€ ê²½ë¡œì— 'summoner_images' í´ë”ê°€ ìˆë‹¤ê³  ê°€ì •)
        const imagePath = 'summoner_images/'; 
        // ì´ë¯¸ì§€ íŒŒì¼ í™•ì¥ì (ëª¨ë“  ì´ë¯¸ì§€ê°€ .pngë¼ë©´ 'png'ë¡œ, í˜¼ìš©ëœë‹¤ë©´ ê° ì†Œí™˜ìˆ˜ë³„ë¡œ ê´€ë¦¬ í•„ìš”)
        const imageExtension = '.png'; 

        let myPlacedSummoners = 0;
        let opponentPlacedSummoners = 0;

        let myLeaderSummoner = null;
        let opponentLeaderSummoner = null;

        function createGrid(gridElement, gridType) {
            for (let i = 0; i < grid5x5Size * grid5x5Size; i++) {
                const cell = document.createElement('div');
                cell.classList.add('grid-cell');
                cell.dataset.index = i;
                gridElement.appendChild(cell);

                cell.addEventListener('dragover', dragOver);
                cell.addEventListener('drop', (e) => drop(e, gridType));
            }
        }

        function createBattlefieldGrid() {
            for (let i = 0; i < battlefieldCols * battlefieldRows; i++) {
                const cell = document.createElement('div');
                cell.classList.add('battlefield-cell');
                const colIndex = i % battlefieldCols;
                if (colIndex > myLeaderBattlefieldCol && colIndex < opponentLeaderBattlefieldCol) { 
                     cell.classList.add('shared-column');
                }
                battlefieldGrid.appendChild(cell);
            }
        }

        function createCommonSummonerPool() {
            for (let i = 0; i < summonerNames.length; i++) { 
                const summoner = document.createElement('div');
                summoner.classList.add('summoner', 'summoner-draggable');
                
                // ì´ë¯¸ì§€ ì¶”ê°€
                const img = document.createElement('img');
                img.src = `${imagePath}${summonerNames[i]}${imageExtension}`;
                img.alt = summonerNames[i];
                summoner.appendChild(img);

                summoner.setAttribute('draggable', true); 
                summoner.id = `summoner-pool-${summonerNames[i]}`;
                summoner.dataset.summonerName = summonerNames[i];
                summoner.dataset.isLeader = 'false';
                commonSummonersPool.appendChild(summoner);

                summoner.addEventListener('dragstart', dragStart);
            }
        }

        function addSummonerButtons(summonerElement) {
            let leaderBtn = summonerElement.querySelector('.leader-button');
            if (!leaderBtn) {
                leaderBtn = document.createElement('div');
                leaderBtn.classList.add('summoner-button', 'leader-button');
                leaderBtn.textContent = (summonerElement.dataset.isLeader === 'true') ? 'ğŸ‘‘' : 'L';
                leaderBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    toggleLeader(summonerElement);
                });
                summonerElement.appendChild(leaderBtn);
            }

            let removeBtn = summonerElement.querySelector('.remove-button');
            if (!removeBtn) {
                removeBtn = document.createElement('div');
                removeBtn.classList.add('summoner-button', 'remove-button');
                removeBtn.textContent = 'X';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    removeSummoner(summonerElement);
                });
                summonerElement.appendChild(removeBtn);
            }
        }

        function removeSummonerButtons(summonerElement) {
            const leaderBtn = summonerElement.querySelector('.leader-button');
            if (leaderBtn) {
                leaderBtn.remove();
            }
            const removeBtn = summonerElement.querySelector('.remove-button');
            if (removeBtn) {
                removeBtn.remove();
            }
        }

        let draggedSummoner = null; 

        function dragStart(e) {
            draggedSummoner = e.target;
            
            // ì´ë¯¸ì§€ ìì²´ë¥¼ ë“œë˜ê·¸í•  ê²½ìš° ë¶€ëª¨ ì†Œí™˜ìˆ˜ divë¥¼ draggedSummonerë¡œ ì„¤ì •
            if (draggedSummoner.tagName === 'IMG') {
                draggedSummoner = draggedSummoner.closest('.summoner');
                if (!draggedSummoner) return; // ìœ íš¨í•œ ì†Œí™˜ìˆ˜ divê°€ ì•„ë‹ˆë©´ ì·¨ì†Œ
            }

            if (draggedSummoner.parentElement.id === 'common-summoners-pool') {
                draggedSummoner.dataset.isPoolOriginal = 'true';
            } else { 
                draggedSummoner.dataset.isPoolOriginal = 'false';
            }

            setTimeout(() => {
                draggedSummoner.style.opacity = '0.5';
                
                if (draggedSummoner.parentElement && draggedSummoner.parentElement.classList.contains('grid-cell')) {
                    draggedSummoner.parentElement.removeChild(draggedSummoner);
                }
            }, 0);
        }

        function dragOver(e) {
            e.preventDefault();
        }

        function drop(e, targetGridType) {
            e.preventDefault();
            if (!draggedSummoner) return;

            const targetCell = e.target.closest('.grid-cell');
            const draggedIsPoolOriginal = draggedSummoner.dataset.isPoolOriginal === 'true';

            if (!targetCell) { 
                if (!draggedIsPoolOriginal) { 
                    removeSummonerFromGrid(draggedSummoner); 
                    draggedSummoner.remove(); 
                }
                draggedSummoner.style.opacity = '1';
                draggedSummoner.removeAttribute('data-is-pool-original'); 
                draggedSummoner = null;
                updateLeaderMarkers();
                updateBattlefield();
                return;
            }
            
            const willBeOpponent = (targetGridType === 'opponent');

            let summonerToPlace = null; 

            if (draggedIsPoolOriginal) { 
                const currentPlacedCount = willBeOpponent ? opponentPlacedSummoners : myPlacedSummoners;
                if (currentPlacedCount >= maxSummoners) {
                    alert(`ë” ì´ìƒ ì†Œí™˜ìˆ˜ë¥¼ ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ìµœëŒ€ ${maxSummoners}ë§ˆë¦¬)`);
                    draggedSummoner.style.opacity = '1';
                    draggedSummoner.removeAttribute('data-is-pool-original');
                    draggedSummoner = null;
                    return;
                }

                summonerToPlace = draggedSummoner.cloneNode(true);
                summonerToPlace.classList.remove('summoner-draggable');
                summonerToPlace.classList.add('is-placed');
                summonerToPlace.removeAttribute('id'); 
                summonerToPlace.setAttribute('draggable', true); 
                summonerToPlace.addEventListener('dragstart', dragStart);

                summonerToPlace.dataset.isLeader = 'false';
                
                summonerToPlace.dataset.isOpponent = willBeOpponent.toString();
                
                draggedSummoner.style.opacity = '1';
                draggedSummoner.removeAttribute('data-is-pool-original');

            } else { // ì´ë¯¸ ë°°ì¹˜ëœ í´ë¡  ì†Œí™˜ìˆ˜ë¥¼ ë“œë˜ê·¸í•œ ê²½ìš°
                summonerToPlace = draggedSummoner;
                
                const originalGridIsOpponent = summonerToPlace.dataset.isOpponent === 'true'; 
                if (originalGridIsOpponent !== willBeOpponent) { // ë‹¤ë¥¸ ì§„ì˜ ê·¸ë¦¬ë“œë¡œ ì´ë™
                    if (originalGridIsOpponent) { // ìƒëŒ€ -> ë‚˜ì˜ ê·¸ë¦¬ë“œ
                        opponentPlacedSummoners--;
                        myPlacedSummoners++;
                    } else { // ë‚˜ì˜ -> ìƒëŒ€ ê·¸ë¦¬ë“œ
                        myPlacedSummoners--;
                        opponentPlacedSummoners++;
                    }
                    if (opponentLeaderSummoner === summonerToPlace) opponentLeaderSummoner = null;
                    if (myLeaderSummoner === summonerToPlace) myLeaderSummoner = null;
                    
                    summonerToPlace.classList.remove('is-leader'); 
                    summonerToPlace.dataset.isLeader = 'false';
                }
                summonerToPlace.dataset.isOpponent = willBeOpponent.toString(); 
            }

            if (targetCell && !targetCell.hasChildNodes()) { // ì…€ì´ ë¹„ì–´ìˆì„ ë•Œ
                targetCell.appendChild(summonerToPlace);
                if (draggedIsPoolOriginal) { 
                    if (willBeOpponent) {
                        opponentPlacedSummoners++;
                    } else {
                        myPlacedSummoners++;
                    }
                }
            } else if (targetCell && targetCell.hasChildNodes()) { // ì…€ì— ì´ë¯¸ ì†Œí™˜ìˆ˜ê°€ ìˆì„ ë•Œ (êµì²´)
                const existingSummoner = targetCell.firstChild;
                
                removeSummonerFromGrid(existingSummoner); 
                existingSummoner.remove(); 

                targetCell.appendChild(summonerToPlace);
            } 
            summonerToPlace.style.opacity = '1';
            addSummonerButtons(summonerToPlace);
            
            draggedSummoner = null;
            updateLeaderMarkers();
            updateBattlefield();
        }

        function removeSummoner(summonerElement) {
            const parentCell = summonerElement.parentElement;
            if (parentCell && parentCell.classList.contains('grid-cell')) {
                removeSummonerFromGrid(summonerElement);
                summonerElement.remove(); 
                
                updateLeaderMarkers();
                updateBattlefield();
            }
        }

        function removeSummonerFromGrid(summonerElement) {
            const isOpponent = summonerElement.dataset.isOpponent === 'true';
            if (isOpponent) {
                opponentPlacedSummoners--;
                if (opponentLeaderSummoner === summonerElement) {
                    opponentLeaderSummoner = null;
                }
            } else {
                myPlacedSummoners--;
                if (myLeaderSummoner === summonerElement) {
                    myLeaderSummoner = null;
                }
            }
            summonerElement.dataset.isLeader = 'false';
        }

        function toggleLeader(summonerElement) {
            const isOpponent = summonerElement.dataset.isOpponent === 'true';
            let currentLeader = isOpponent ? opponentLeaderSummoner : myLeaderSummoner;

            if (!summonerElement.parentElement.classList.contains('grid-cell')) {
                return; 
            }

            if (summonerElement.dataset.isLeader === 'true') {
                summonerElement.dataset.isLeader = 'false';
                if (isOpponent) {
                    opponentLeaderSummoner = null;
                } else {
                    myLeaderSummoner = null;
                }
            } else {
                if (currentLeader) {
                    currentLeader.dataset.isLeader = 'false';
                }
                summonerElement.dataset.isLeader = 'true';
                if (isOpponent) {
                    opponentLeaderSummoner = summonerElement;
                } else {
                    myLeaderSummoner = summonerElement;
                }
            }
            updateLeaderMarkers();
            updateBattlefield();
        }

        function updateLeaderMarkers() {
            document.querySelectorAll('.grid-cell .summoner').forEach(s => {
                s.classList.remove('is-leader');

                const leaderBtn = s.querySelector('.leader-button');
                if (leaderBtn) {
                    leaderBtn.textContent = 'L';
                }
            });

            [myLeaderSummoner, opponentLeaderSummoner].forEach(leader => {
                if (leader && leader.parentElement && leader.parentElement.classList.contains('grid-cell')) {
                    leader.classList.add('is-leader');
                    const leaderBtn = leader.querySelector('.leader-button');
                    if (leaderBtn) {
                        leaderBtn.textContent = 'ğŸ‘‘';
                    }
                }
            });
        }

        function updateBattlefield() {
            battlefieldGrid.innerHTML = '';
            createBattlefieldGrid();

            const battlefieldCells = battlefieldGrid.querySelectorAll('.battlefield-cell');
            
            for (let r = 0; r < battlefieldRows; r++) {
                for (let c = myLeaderBattlefieldCol + 1; c < opponentLeaderBattlefieldCol; c++) { 
                     const battlefieldIndex = r * battlefieldCols + c;
                     if (battlefieldCells[battlefieldIndex]) {
                         battlefieldCells[battlefieldIndex].classList.add('shared-column');
                     }
                }
            }

            const myPlacedSummonersData = collectSummonersData(myGrid);
            const opponentPlacedSummonersData = collectSummonersData(opponentGrid);

            let myLeaderOriginalPos = myPlacedSummonersData.find(s => s.isLeader);
            let opponentLeaderOriginalPos = opponentPlacedSummonersData.find(s => s.isLeader);

            const battlefieldPlacementMap = new Map();

            if (myLeaderSummoner && myLeaderSummoner.parentElement && myLeaderSummoner.parentElement.classList.contains('grid-cell')) {
                const key = `${battlefieldVerticalCenterRow},${myLeaderBattlefieldCol}`;
                if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                battlefieldPlacementMap.get(key).push(myLeaderSummoner);
            }
            myPlacedSummonersData.forEach(data => {
                if (!data.isLeader) { 
                    let bfRow, bfCol;
                    if (myLeaderOriginalPos) {
                        const rowDiff = data.originalRow - myLeaderOriginalPos.originalRow;
                        const colDiff = data.originalCol - myLeaderOriginalPos.originalCol;
                        bfRow = battlefieldVerticalCenterRow + rowDiff;
                        bfCol = myLeaderBattlefieldCol + colDiff;
                    } else {
                        bfRow = battlefieldVerticalCenterRow - 2 + data.originalRow;
                        bfCol = 0 + data.originalCol; 
                    }
                    if (bfRow >= 0 && bfRow < battlefieldRows && bfCol >= 0 && bfCol < battlefieldCols) {
                        const key = `${bfRow},${bfCol}`;
                        if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                        battlefieldPlacementMap.get(key).push(data.summoner);
                    }
                }
            });

            if (opponentLeaderSummoner && opponentLeaderSummoner.parentElement && opponentLeaderSummoner.parentElement.classList.contains('grid-cell')) {
                const key = `${battlefieldVerticalCenterRow},${opponentLeaderBattlefieldCol}`;
                if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                battlefieldPlacementMap.get(key).push(opponentLeaderSummoner);
            }
            opponentPlacedSummonersData.forEach(data => {
                if (!data.isLeader) { 
                    let bfRow, bfCol;
                    const rotatedRow = (grid5x5Size - 1) - data.originalRow;
                    const rotatedCol = (grid5x5Size - 1) - data.originalCol;

                    if (opponentLeaderOriginalPos) {
                        const leaderRotatedRow = (grid5x5Size - 1) - opponentLeaderOriginalPos.originalRow;
                        const leaderRotatedCol = (grid5x5Size - 1) - opponentLeaderOriginalPos.originalCol;

                        const rowDiff = rotatedRow - leaderRotatedRow;
                        const colDiff = rotatedCol - leaderRotatedCol;
                        
                        bfRow = battlefieldVerticalCenterRow + rowDiff;
                        bfCol = opponentLeaderBattlefieldCol + colDiff;

                    } else {
                        bfRow = battlefieldVerticalCenterRow - 2 + rotatedRow;
                        bfCol = 8 + rotatedCol; 
                    }
                    if (bfRow >= 0 && bfRow < battlefieldRows && bfCol >= 0 && bfCol < battlefieldCols) {
                        const key = `${bfRow},${bfCol}`;
                        if (!battlefieldPlacementMap.has(key)) battlefieldPlacementMap.set(key, []);
                        battlefieldPlacementMap.get(key).push(data.summoner);
                    }
                }
            });

            battlefieldPlacementMap.forEach((summonersInCell, key) => {
                const [rowStr, colStr] = key.split(',');
                const bfRow = parseInt(rowStr);
                const bfCol = parseInt(colStr);
                const battlefieldIndex = bfRow * battlefieldCols + bfCol;
                const bfCell = battlefieldCells[battlefieldIndex];

                // ì…€ì— ìˆëŠ” ì†Œí™˜ìˆ˜ ìˆ˜ì— ë”°ë¼ battlefield-cellì˜ ê·¸ë¦¬ë“œ í…œí”Œë¦¿ ë³€ê²½
                if (summonersInCell.length === 1) {
                    bfCell.classList.remove('multi-summoners'); // 1x1 ê·¸ë¦¬ë“œ ìœ ì§€
                    bfCell.style.gridTemplateColumns = '1fr'; 
                    bfCell.style.gridTemplateRows = '1fr';
                } else if (summonersInCell.length === 2) {
                    bfCell.classList.add('multi-summoners'); // 2ì—´ 1í–‰ ê·¸ë¦¬ë“œ í™œì„±í™”
                    bfCell.style.gridTemplateColumns = 'repeat(2, 1fr)'; /* ê°€ë¡œ 2ë¶„í•  */
                    bfCell.style.gridTemplateRows = '1fr'; /* ì„¸ë¡œëŠ” 1ì¹¸ */
                } else { /* summonersInCell.length >= 3 */
                    bfCell.classList.add('multi-summoners'); // 2x2 ê·¸ë¦¬ë“œ í™œì„±í™”
                    bfCell.style.gridTemplateColumns = 'repeat(2, 1fr)'; /* ê°€ë¡œ 2ë¶„í•  */
                    bfCell.style.gridTemplateRows = 'repeat(2, 1fr)'; /* ì„¸ë¡œ 2ë¶„í•  */
                }

                // ì†Œí™˜ìˆ˜ë“¤ì´ ì…€ ë‚´ ê·¸ë¦¬ë“œì— ë°°ì¹˜ë  ìœ„ì¹˜ë¥¼ ì •ì˜
                // 1ë§ˆë¦¬: (1,1), 2ë§ˆë¦¬: (1,1), (1,2), 3ë§ˆë¦¬: (1,1), (1,2), (2,1), 4ë§ˆë¦¬: (1,1), (1,2), (2,1), (2,2)
                const positions2x2 = [[1,1], [1,2], [2,1], [2,2]]; // 2x2 ê·¸ë¦¬ë“œìš© ìœ„ì¹˜

                summonersInCell.forEach((summonerElement, index) => {
                    if (index < positions2x2.length) { // ìµœëŒ€ 4ë§ˆë¦¬ê¹Œì§€ ê³ ë ¤
                        const bfSummoner = document.createElement('div');
                        bfSummoner.classList.add('battlefield-summoner'); 
                        bfSummoner.classList.add(summonerElement.dataset.isOpponent === 'true' ? 'opponent-summoner' : 'my-summoner');
                        
                        // ì†Œí™˜ìˆ˜ ìˆ˜ì— ë”°ë¼ ë‹¤ë¥¸ í¬ê¸° í´ë˜ìŠ¤ ë¶€ì—¬ ë° ìœ„ì¹˜ ì§€ì •
                        if (summonersInCell.length === 1) {
                            bfSummoner.classList.add('single-summoner');
                            // 1x1 ê·¸ë¦¬ë“œì—ì„œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì…€ ì „ì²´ë¥¼ ì°¨ì§€
                            bfSummoner.style.gridRowStart = '1';
                            bfSummoner.style.gridColumnStart = '1';
                        } else if (summonersInCell.length === 2) {
                            bfSummoner.classList.add('multi-summoner');
                            // 2ë§ˆë¦¬ì¼ ë•Œ ê°€ë¡œë¡œ ë‚˜ë€íˆ (1ì—´1í–‰, 1ì—´2í–‰)
                            bfSummoner.style.gridRowStart = '1';
                            bfSummoner.style.gridColumnStart = index + 1; 
                        } else { // 3ë§ˆë¦¬ ì´ìƒì€ 2x2 ê·¸ë¦¬ë“œë¡œ
                            bfSummoner.classList.add('multi-summoner');
                            bfSummoner.style.gridRowStart = positions2x2[index][0];
                            bfSummoner.style.gridColumnStart = positions2x2[index][1];
                        }

                        bfSummoner.innerHTML = `<img src="${imagePath}${summonerElement.dataset.summonerName}${imageExtension}" alt="${summonerElement.dataset.summonerName}">`;
                        
                        if (summonerElement.dataset.isLeader === 'true') {
                            const leaderMarker = document.createElement('span');
                            leaderMarker.classList.add('battlefield-leader-marker');
                            leaderMarker.textContent = 'ğŸ‘‘';
                            bfSummoner.appendChild(leaderMarker);
                        }
                        bfCell.appendChild(bfSummoner);
                    }
                });
            });
        }

        function collectSummonersData(gridElement) {
            const placedSummonersData = [];
            gridElement.querySelectorAll('.grid-cell').forEach((gridCell, gridIndex) => {
                if (gridCell.firstChild) {
                    const summoner = gridCell.firstChild; 
                    const name = summoner.dataset.summonerName;
                    const isLeader = summoner.dataset.isLeader === 'true';
                    const originalRow = Math.floor(gridIndex / grid5x5Size);
                    const originalCol = gridIndex % grid5x5Size;
                    placedSummonersData.push({ summoner, name, isLeader, originalRow, originalCol });
                }
            });
            return placedSummonersData;
        }

        // ì´ˆê¸°í™”
        createBattlefieldGrid();
        createGrid(myGrid, 'my');
        createGrid(opponentGrid, 'opponent');
        createCommonSummonerPool();
        updateBattlefield();
    </script>
</body>
</html>